#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_EXTRA_CSS: ./emoji.css
#+REVEAL_ROOT: ../reveal.js/

#+TITLE: Easy to Use, Hard to Misuse
#+AUTHOR: Ben Deane
#+EMAIL: bdeane@blizzard.com
#+DATE: Thursday May 10th, 2018

#+REVEAL_HTML: <script type="text/javascript" src="./presentation.js"></script>

* Title slide settings                                             :noexport:
#+BEGIN_SRC emacs-lisp
(setq org-reveal-title-slide
(concat "<div class='vertspace6'/>"
"<h3>%t</h3><h2>Declarative Style in C++</h2></div>"
"<h3>%a / <a href=\"mailto:bdeane@blizzard.com\">bdeane@blizzard.com</a> / "
"<a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3>"
"<h4>C++Now / %d</h4>"))
(set-face-foreground 'font-lock-comment-face "dark green")
#+END_SRC

* Declarative Style
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"I keep hearing this term and every time I hear it the definition seems very hand-wavy."
#+REVEAL_HTML: <div></div><div class='author'>
-- A C++Now submission reviewer
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
This quote from the reviewers who accepted my talk.

This talk is going to be part philosophy, part history, and hopefully a good
part pragmatism. I'm not going to give you a lot of "pure functional"
rabbit-holing.

I'm going to try to find specific guidelines that will fit with C++ as a large,
multiparadigm language.
#+END_NOTES

* In This Talk
#+REVEAL_HTML: <div class='vertspace2'></div>
1. Definitions & motivation
1. Where we came from
1. Where we are
1. Where we could be headed

#+BEGIN_NOTES
I'm going to try to look at the history of programming and C++ and the current
practices that exist, and I'm going to look through a declarative lens.

The goal is to see how to apply declarative programming principals to make our
C++ better, in the context of this large, multiparadigm language that isn't
necessarily always amenable to naive pure functional declarative techniques.
#+END_NOTES

* What Do We Mean?
** Wikipedia
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"A programming paradigm ... that expresses the logic of a computation without
describing its control flow."
#+END_QUOTE

#+BEGIN_NOTES
Removing control flow complexity is an important idea.

You may be thinking, "control flow is sort of important to C++, I'm not sure we
can ditch it entirely."

I'll expand on this as we go.
#+END_NOTES

** wiki.c2.com
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"Often it involves the separation of 'facts' from operations on the facts."
#+END_QUOTE
#+BEGIN_QUOTE
"... generalizes the pure functional model."
#+END_QUOTE

#+ATTR_REVEAL: :frag (appear)
 - commutativity
 - idempotency

#+BEGIN_NOTES
Ward Cunningham's original wiki. Home to the "Informal History of Programming
Ideas".

Order of statements should not affect semantics. Replication of statements
should not affect semantics.

But from what else it says, this website seems to be talking more about say,
Prolog, than C++.
#+END_NOTES

** Language Classifications?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 - imperative/procedural (FORTRAN, C)
 - object-oriented (Smalltalk, Java)
 - functional (ML, Haskell)
 - etc.

#+BEGIN_NOTES
Many general-purpose languages (certainly of the last 30-40 years) resist strict
classification.

It's a bit like trying to classify music: there is a lot of overlap and a lot of
subgenres. People say "classical music" commonly meaning anything from Bach to
John Williams.

On this list, even Haskell can be programmed "imperatively".

We would say that C++ is multiparadigm of course. Procedural, OO, functional,
generic at least.
#+END_NOTES

** Complexity and line count
#+REVEAL_HTML: <div class='vertspace2'></div>
Fewer lines of code => fewer bugs?

<insert hand-wave here?>

#+BEGIN_NOTES
It's an uncomfortable statistic that bug count correlates with line count.

Like any statistic, we can find counterexamples. To me it's a bit like saying
that on average, men are taller than women.

What we want is to decrease complexity and increase reason-ability. One of the
important tools for that is idiom - which may increase line count!

Declarative style often leads to decreasing line count, but this isn't a goal in
and of itself.
#+END_NOTES

** Declarative Style Motivation
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"Declarative programming is everyone's dream, because it looks like it's easier
to prove correct."
#+REVEAL_HTML: <div></div><div class='author'>
-- Another C++Now submission reviewer
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
This quote also from the reviewers who accepted my talk.

I'm not sure there's going to be any proving in this talk, but for me this
speaks to the fact that declarative style tends to focus on expressions and
minimize the use of statements.

I would say that it is easier to convince ourselves that it is correct.
#+END_NOTES

** Declarative Style Indicators
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 - referential transparency
 - say WHAT in preference to HOW
 - minimize imperative style
 - expressions over statements
 - declaring things

#+BEGIN_NOTES
Declarative style is not a hard-and-fast thing, especially not in C++.

It's rather a way of tailoring the code.

At the risk of being etymologically reductive, in part it's a preference for
using declarations.

Next: Expressions vs Statements
#+END_NOTES

* Expressions vs Statements
#+BEGIN_NOTES
Let's compare and contrast and see what we can discover.

What does the standard say?
#+END_NOTES

** Expressions
#+REVEAL_HTML: <div class='vertspace2'></div>
"An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side effects." [expr.pre] \S 1
#+REVEAL_HTML: <div class='vertspace2'></div>
Properties of expressions:
#+ATTR_REVEAL: :frag (appear)
 - value category
 - type

#+BEGIN_NOTES
The standard has a lot to say about expressions in general before even going
into detail about kinds of expressions and how to make them.

There is the familiar value-category tree (lvalue, xvalue, prvalue, etc), which
has "expression" at its root.

Expressions have intrinsic properties that can be reasoned about.

There is also "context dependence" which is to do with unevaluated contexts and
evaluation for side effects only. A bit of standardese, really.
#+END_NOTES

** Expressions Compose On Multiple Axes
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
auto expr = a @ b @ c;
#+END_SRC
#+REVEAL_HTML: <div class='vertspace2'></div>
Consider this snippet.

#+BEGIN_NOTES
Here, @ is any operator.

There are at least two obvious kinds of composition going on here.

a, b, and c have values. expr has a value.

a, b, and c have types. expr has a type.

Expressions compose on the value axis, and also on the type axis.
Value-composition happens at runtime, and type composition happens at
compile-time. So it can be checked.
#+END_NOTES

** Statements
#+REVEAL_HTML: <div class='vertspace2'></div>
"Except as indicated, statements are executed in sequence." [stmt.stmt] \S 1
#+REVEAL_HTML: <div class='vertspace2'></div>
Properties of statements:
#+ATTR_REVEAL: :frag (appear)
 - er...

#+BEGIN_NOTES
The standard doesn't have a lot to say about statements in general. They are
defined extrinsically, simply by enumerating the different kinds of statements
that we can write.

There are no real intrinsic properties of statements.
#+END_NOTES

** Statements "Compose" Only By Sequencing
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
x;
y;
z;
#+END_SRC
 - no type checking
 - value checking is manual, intrusive
 - implicit constraints
 - temporal reasoning is poor

#+BEGIN_NOTES
Statements "compose" only by sequencing. There is no direct way to constrain this.
No type checking.

Some value checking is done with asserts. I say intrusive because assert itself
is a statement; asserting expressions doesn't change the expressions, but
asserting statements changes the flow of statements.

We have (varyingly implicit) constraints with pre- and post-conditions, and
variable lifetime extents. We use variable scoping to control things.

Dijkstra: "Our intellectual powers are rather geared to master static relations
and our powers to visualize processes evolving in time are relatively poorly
developed."
#+END_NOTES

** Imperative Safety Gear
#+REVEAL_HTML: <div class='vertspace2'></div>
Many of our guidelines, best practices, idioms, and much of our tooling, static
and dynamic analysis, is in service of checking the implicit constraints around
statement "composition".

#+BEGIN_NOTES
We put a lot of effort into controlling statements!

We make conventions. We make guidelines.

We make tools. We like to run multiple static analysers to get different
benefits from each.

We make more tools. We make libraries in support of those tools. We add things
to the language to help us manage this problem. We have a contracts proposal!

This is all well and good, but here's an alternative: use fewer statements and
more expressions.
#+END_NOTES

** Declarative Style: Avoid Statements!
#+REVEAL_HTML: <div class='vertspace2'></div>
 - expression statement
 - selection statement (~if~, ~switch~)
 - iteration statement (~for~, ~while~, ~do~)
 - jump statement (~break~, ~continue~, ~return~, ~goto~)
 - declaration statement

#+BEGIN_NOTES
Declarative style is essentially a preference for avoiding statements.

Here are the statements available to us. (For the language lawyers, I left out
compound statements (if we get rid of other statements, we mostly get rid of
them), try blocks and atomic/synchronized blocks from the TM TS.) Only the last
of these (declaration statement) is good.

As a goal, we should try to avoid most of the rest where we can. It's not a
hard-and-fast rule; it's a goal.

Avoiding statements may sound odd at first. But I hope to show that when we look
at current practice through this lens, we'll see that it's what we're already
doing, even if we don't realise it.
#+END_NOTES

* Let's Examine History...
#+REVEAL_HTML: <div class='vertspace2'></div>
Let's look at where we've come from, and see how it informs moving to
declarative style.

#+BEGIN_NOTES
Let's look first at expression statements.

The easiest target.

"Most statements in a typical C++ program are expression statements, such as
assignments or function calls." -- cppreference.com
#+END_NOTES

** World's Last Bug
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
while (true)
{
  status = GetRadarInfo();
  if (status = 1)
    LaunchMissiles();
}
#+END_SRC
Ancient history you say?

#+BEGIN_NOTES
Assignment is the king of expression statements.

Two odd things here. Let's digress a bit and consider how history brought us to
the current situation.
#+END_NOTES

** Odd Thing #1: Assignments are Expressions
#+REVEAL_HTML: <div class='vertspace2'></div>
Assignment as an expression is a historical choice.

It's doing us no favours today.

Assignment should be a statement.

#+BEGIN_NOTES
I don't know whether this is a particularly controversial thing to say.

When I was at university, I learned C and Modula-3. Some of my friends were
already used to programming in C. Because of that, we frequently ran up against
a particular error in Modula-3.
#+END_NOTES

** Odd Thing #1: Assignments are Expressions
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"Expression is not a statement."
#+REVEAL_HTML: <div></div><div class='author'>
-- Modula-3 compiler, 1993
#+REVEAL_HTML: </div>
#+END_QUOTE
#+REVEAL_HTML: <br clear="all"/>

And quite right, too.

#+BEGIN_NOTES
But this didn't start with C: so-called expression-oriented languages were
already around for a while, notably ALGOL-68 (1968) and LISP (1958).

So we need to go back a bit.
#+END_NOTES

** Odd Thing #1: Assignments are Expressions
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
/* The following function will print a non-negative number, n, to
   the base b, where 2<=b<=10.  This routine uses the fact that
   in the ASCII character set, the digits 0 to 9 have sequential
   code values.  */
printn(n, b) {
    extrn putchar;
    auto a;

    if (a = n / b)    /* assignment, not test for equality */
        printn(a, b); /* recursive */
    putchar(n % b + '0');
}
#+END_SRC

#+BEGIN_NOTES
I had to tell my syntax highlighter that this was C. Does anyone know what
language this is?

From the Users' Reference to B by Ken Thompson. (B: 1969)

B was descended from Martin Richards' BCPL (1967), which had an assignment
command, not an assignment expression.
#+END_NOTES

** Odd Thing #1: Assignments are Expressions
#+REVEAL_HTML: <div class='vertspace2'></div>
We've learned to deal with this. But we don't really like it.
#+ATTR_REVEAL: :frag (appear)
 - yoda conditions
 - compiler warnings
 - P0963: discouraged

#+BEGIN_NOTES
This is a holdover from history that we increasingly don't like, and we're
increasingly finding ways to avoid. P0963: structured binding declaration as a
condition
#+END_NOTES

** Odd Thing #2: = Means Assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
/* The following function will print a non-negative number, n, to
   the base b, where 2<=b<=10.  This routine uses the fact that
   in the ASCII character set, the digits 0 to 9 have sequential
   code values.  */
printn(n, b) {
    extrn putchar;
    auto a;

    if (a = n / b)    /* assignment, not test for equality */
        printn(a, b); /* recursive */
    putchar(n % b + '0');
}
#+END_SRC

#+BEGIN_NOTES
The same snippet of B.

Note the comment. We're used to this today. But it's worth asking why it is that
way.
#+END_NOTES

** Odd Thing #2: = Means Assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"A notorious example for a bad idea was the choice of the equal sign to denote
assignment."
#+REVEAL_HTML: <div></div><div class='author'>
-- Niklaus Wirth
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
"Because it overthrows a century old tradition to let “=” denote a comparison
for equality, a predicate which is either true or false."

"the operands are on unequal footing ... x = y does not mean the same thing as y = x."

From this I conclude that Niklaus Wirth is not really a fan of operator
overloading. We'll come back to this idea later.
#+END_NOTES

** Odd Thing #2: = Means Assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 - Superplan (1951) introduced ~=~ for assignment
 - FORTRAN (1957) used ~=~ (because ~.GT.~ ~.LT.~ ~.EQ.~ etc)
 - ALGOL-58 introduced ~:=~ (assignment) distinct from ~=~ (equality)
  - Subsequently many languages went this way
 - BCPL (1967) used ~:=~
 - B (1969) simplified a lot of BCPL syntax, went with ~=~
  - Followed by C (1972) and many other languages

#+BEGIN_NOTES
The 50s and 60s was an incredible time for programming language innovation.
Superplan introduced the for loop!

FORTRAN had to use a very restricted character set. There were no greater than
or less than symbols, hence the idiosyncratic relational operators and the
freeing up of equals for assignment.

B is responsible for almost all the operators we have in C++ today.
#+END_NOTES

** Odd Thing #2: = Means Assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_QUOTE
"Since assignment is about twice as frequent as equality testing
in typical programs, it’s appropriate that the operator be half as long."
#+REVEAL_HTML: <div></div><div class='author'>
-- Ken Thompson
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
Ken Thompson wanted to fit BCPL on the PDP-7. BCPL's compiler at the time was
16k. PDP-7 had 4k of memory. So Ken cut down the number of characters in source
wherever he could.
#+END_NOTES

** Declaration vs (Re-)Assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
In moving from BCPL to B, the distinction between

declaration and reassignment was blurred.
#+BEGIN_SRC c++
int a = 42; // declaration/initialization

a = 1729; // assignment
#+END_SRC

#+BEGIN_QUOTE
"It cannot be overemphasized that *assignment and initialization are different
operations*."
#+REVEAL_HTML: <div></div><div class='author'>
-- Bjarne Stroustrup, /The C++ Programming Language/
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
Early languages (50s and 60s) often distinguished const-declaration from
variable-decl-and-assignment. ALGOL-68 for example. Pascal-type languages still
do.

Consider ~int~ here replaced with ~let~, and you have a mathematical declaration
or variable introduction. A mathematical assignment is nonsensical.

This distinction was clear in BCPL, which uses = for declaration and := for
reassignment. But the cutting-down-for-memory of B introduced ambiguity.
#+END_NOTES

** <End of Historical Diversion>
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 * Declaring things is -- has always been -- fine.
 * Declaration and assignment are different things that look the same.
 * Assignment as an expression statement is best avoided.
   - Chained assignments are a syntactic laziness.

#+BEGIN_NOTES
What does a look at history tell us about programming style, especially
declarative style?

Assignment as an expression is a lazy convenience that doesn't do us any
favours. Expression statements have always been a trap for the unwary.

That's why we have warnings for things like this. And that's why we have things
like if-initializers and nodiscard attributes.

I can think of no reason to use chained assignments. I grepped my code base and
found zero occurrences.
#+END_NOTES

** Declarative Style: Avoiding Statements
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Statement</td>
#+REVEAL_HTML: <th class="org-left">Status</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">assignment</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-broken_heart"></i></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">selection</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">iteration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">jump</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">declaration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
Assignment used as an expression per se is looking on shaky ground.
We don't like it.

 - -wunused-value ("statement has no effect")
 - yoda conditions

Best avoided. Prefer declarations, some of us use AAA, many of us use const
where we can.

We guard against expression statements in general: ~nodiscard~ attribute in
C++17.
#+END_NOTES

* A Quick Declarative Study

#+BEGIN_NOTES
Let's look at a fairly common code snippet and examine some different ways to
write it in a modern, potentially declarative style.
#+END_NOTES

** Example
#+REVEAL_HTML: <div class='vertspace2'></div>
Given:
#+BEGIN_SRC c++
weak_ptr<Foo> wp;
#+END_SRC
How to write:
#+BEGIN_SRC c++
Bar b;
{
  auto sp = wp.lock();
  if (sp) b = sp->bar();
}
#+END_SRC
In a (more) declarative way.

#+BEGIN_NOTES
Here is an imperative piece of code. What's wrong with it?

 - declaration/initialization split (b could well be const after init)
 - mutable state
 - scope control (note convention)

This code would likely pass code review. It's the best we can do with imperative
style. It's ticking several guideline boxes. But it's still unsatisfying.

I'm using ~shared_ptr~ here as a standin for some generic access that requires
this kind of pattern: the pattern is not just for ~shared_ptr~.
#+END_NOTES

** C++17 if-initializer?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
Bar b;
if (auto sp = wp.lock(); sp)
  b = sp->bar();
#+END_SRC
This still has the declaration/initialization split. Still has mutable state.

#+BEGIN_NOTES
Note: this is sort of a workaround for the assignment being an expression.

I think it likely that this will become a style that replaces the simple
assignment-as-an-expression.
#+END_NOTES

** Conditional operator?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
Bar b = wp.lock() ? wp.lock()->bar() : Bar{};
#+END_SRC
Hm...

#+BEGIN_NOTES
This works. Temporary lives until semicolon? But double lock.
#+END_NOTES

** C++?? conditional-operator-initializer?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
// this isn't real syntax...
Bar b = [auto sp = wp.lock(); sp] ? sp->bar() : Bar{};
#+END_SRC
Might be nice... but not today.

#+BEGIN_NOTES
Expressions and statements aren't equivalent, even when they "are".

Unlike ~if~, syntax doesn't allow us to put a declaration in the condition.
#+END_NOTES

** GCC Extension?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
Bar b =
({
  auto sp = wp.lock();
  sp ? sp->bar() : Bar{};
});
#+END_SRC
Not ISO C++.

#+BEGIN_NOTES
GCC has an extension called an expression statement.

This is similar to how a compound statement might be handled in a functional
language, where the value of the statement is the value of the last statement in
the body.

Of course this leads us to what many of you were already thinking...
#+END_NOTES

** I+LE?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
Bar b = [&] () {
  if (auto sp = wp.lock(); sp) return sp->bar();
  return Bar{};
}();
#+END_SRC
Immediately-invoked, inline, initializing, ...

#+BEGIN_NOTES
Very much in vogue at the moment.

This might be OK? Avoids declaration/initialization split anyway. Depends on
your codebase style.
#+END_NOTES

** Optional-like?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
Bar b = get_bar_or(wp.lock(), Bar{});
#+END_SRC
Not really generic enough.

#+BEGIN_NOTES
This is a good interface for optional, but (at least until we have reflection)
we can't parameterize over the name of the member variable.
#+END_NOTES

** Functorial/Monadic Interface?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
shared_ptr<Bar> b = fmap(wp.lock(),
                         [] (auto foo) { return foo.bar(); });
#+END_SRC
#+BEGIN_SRC c++
template <typename T, typename F>
[[nodiscard]] auto fmap(const shared_ptr<T>& p, F f)
    -> shared_ptr<invoke_result_t<F, T>>
{
  ...
}
#+END_SRC

#+BEGIN_NOTES
This might be OK? Again depends on your codebase style.

Note the nodiscard attribute: another piece of imperative safety gear that helps
us avoid the pitfalls of statements.
#+END_NOTES

** Study Conclusions
#+REVEAL_HTML: <div class='vertspace2'></div>
"Total" declarative style is not always achievable in C++.

A /more/ declarative style is a reasonable goal.

Some features of C++ help us get there.

Different domains lean towards different approaches.

#+BEGIN_NOTES
IILEs help, nodiscard attribute helps

Different domains: we probably wouldn't want to use a monadic approach for
~shared_ptr~. But we might well want to for futures. For errors, the answer
would probably depend on our codebase's existing practice.

A key idea is to minimize statements and maximize the use of expressions. This
maximizes the compiler's help.
#+END_NOTES

* Existing Declarative Practice
#+REVEAL_HTML: <div class='vertspace2'></div>
We are surrounded by guidelines, goals and idioms.

Looking through a declarative lens, we can tie it together.

** Core Guidelines
#+REVEAL_HTML: <div class='vertspace2'></div>
/~Con.1~/ By default, make objects immutable.

/~Con.4~/ Use ~const~ to define objects with values that do not change after
construction.

/~ES.21~/ Don't introduce a variable (or constant) before you need to use it.

/~ES.22~/ Don't declare a variable until you have a value to initialize it with.

/~ES.28~/ Use lambdas for complex initialization.

#+BEGIN_NOTES
Corollary to /Con.4/: we probably have lots of objects that can be ~const~.

Just watch a few episodes of C++Weekly...
#+END_NOTES

** Declarative Style: Avoiding Statements
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Statement</td>
#+REVEAL_HTML: <th class="org-left">Status</td>
#+REVEAL_HTML: <th class="org-left">Killed by</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">assignment</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">guidelines</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">selection</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">iteration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">jump</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">declaration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
We try to avoid assignment after initialization: assignment as an expression.

This allows us to take advantage of immutability for correctness and
performance, and optimizations like RVO.

This also reduces the need for scoping auxiliary variables and therefore reduces
the need for compound statements.
#+END_NOTES

** Functions in General
#+REVEAL_HTML: <div class='vertspace2'></div>
Which is better?
#+BEGIN_SRC c++
// do A
...
// do B
...
// do C
...
#+END_SRC
or
#+BEGIN_SRC c++
do_A();
do_B();
do_C();
#+END_SRC
?

#+BEGIN_NOTES
From Tony's talk: the number of times you need to see the same code to make a function?

Just 1. So we like functions. Why?
#+END_NOTES

** The "Normal" Reasons
#+REVEAL_HTML: <div class='vertspace2'></div>
 - shorter is more expressive, understandable
 - encapsulation of variable scopes, lifetimes, concerns
 - functions give things names

#+BEGIN_NOTES
These are the normal reasons given for liking functions.

And they're great. I like functions for all these reasons.
#+END_NOTES

** Another Reason
#+REVEAL_HTML: <div class='vertspace2'></div>
Functions turn statements into expressions.

 - ~return~ is the ~goto~ that we love
 - way better than ~break~
 - and if that wasn't enough, RVO

#+BEGIN_NOTES
I am not a fan of "one exit path per function". I don't think this is a
particularly controversial point of view. In C++ it's an antipattern. When you
have RAII, you don't need this!

Early-outs make for shallow, simple conditions. ~return~ can very simply cut out
of find-style algorithms.

According to one of the top answers on stack overflow, the notion of single-exit
was introduced with Structured Programming as a guard against alternate returns,
which were not returns /from/ multiple places but returns /to/ multiple places.
e.g. in FORTRAN when a function had an error it would do an alternate return to
a place where the error was handled.
#+END_NOTES

** <algorithm>
#+REVEAL_HTML: <div class='vertspace2'></div>
No Raw Loops

What does that mean?
 - encapsulate iteration statements
 - encapsulate remaining assignments
 - encapsulate ~break~ and ~continue~

#+BEGIN_NOTES
Algorithms are essentially declarative: they are functions. They are expressive.
They have names. They declare what's going on.

"No raw loops" as a goal is a subset of "strive for declarative code".

It exhorts us to take these statement types and push them down out of the
business logic.
#+END_NOTES

** ~#include "my_algorithms.h"~
#+REVEAL_HTML: <div class='vertspace2'></div>
 - ~min_unused~
 - ~is_prefix_of~
 - ~join~
 - ~transform_if~
 - ~set_differences~ (aka before and after)
 - ~push_back_unique~

#+BEGIN_NOTES
Here is a selection of algorithms in my toolkit.

None of these algorithms is groundbreaking. Some of them are little more than
rebrandings of one-liners. None of them is more than a handful of lines.

What they /do/ is avoid statements in logic. They simplify control flow. Notice
also that all well-written algorithms deal with the edge cases: primarily empty
ranges. You don't have to put conditions or loops in your logic!
#+END_NOTES

** Declarative Style: Avoiding Statements
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Statement</td>
#+REVEAL_HTML: <th class="org-left">Status</td>
#+REVEAL_HTML: <th class="org-left">Killed by</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">assignment</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">guidelines</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">selection</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">iteration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">"no raw loops"</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">jump</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">"no raw loops"</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">declaration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
So, "no raw loops" is leading us to avoid iteration and jump statements.

I+LEs and initialization guidelines lead us to avoid assignments.

Let's look now at how to avoid conditions. Hint: we're already doing it.
#+END_NOTES

* Declarative Domains and Patterns

** Testing
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
TEST_CASE( "Factorials are computed", "[factorial]" ) {
    REQUIRE( Factorial(1) == 1 );
    REQUIRE( Factorial(2) == 2 );
    REQUIRE( Factorial(3) == 6 );
}
#+END_SRC

Conditions are encapsulated; nothing is dependent.
#+ATTR_REVEAL: :frag (appear)
 - idempotent
 - minimal temporal dependency between statements
 - leverage constructors/RAII
 - popularity of sections over fixture management

#+BEGIN_NOTES
This is from Catch.

Testing use macros to hide constructor/RAII syntax. It also uses global state.
Declarative style isn't incompatible with global state; sometimes you have to do
what you have to do.

C++ is a multiparadigm language; declarative style isn't "pure FP or nothing".
#+END_NOTES

** Logging : Imperative turned Declarative
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
fprintf(g_debugLogFilep, "R Tape loading error, %d:%d", line, stmt);
#+END_SRC
vs
#+BEGIN_SRC c++
LOG("R Tape loading error, " << line << ':' << stmt);
#+END_SRC

#+BEGIN_NOTES
Logging is very often declarative. Nothing much new here, but let's explore a
bit because it's a domain that benefits greatly from declarative practice.

We're using overloaded operators. We're using RAII. We've got a declarative,
concatenative style. What has been gained here?

Composability: through operator overloading, we have the ability to extend the
expression, because expressions are composable.

Extensibility: we can provide the operator for our own types.

Type checking: with fprintf, the format string and the arguments have to match
or bad things will happen. Usually the worst we can expect with LOG is that we
get unexpected conversions of the arguments.
#+END_NOTES

** Where Did the Global Go?
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
// g_debugLogFilep is a global variable
fprintf(g_debugLogFilep, "R Tape loading error, %d:%d", line, stmt);
#+END_SRC

#+BEGIN_SRC c++
// somewhere, a "global" variable lurks? where does the log go to?
LOG("R Tape loading error, " << line << ':' << stmt);
#+END_SRC

#+BEGIN_NOTES
Logging framework? What has replaced the global variable? Functions and/or
declarations in the global namespace.

A sink is where logs go to. In the C case, ~g_debugLogFilep~. In the C++ case, a
global variable that is hidden inside the RAII object constructed with LOG.

The benefits of declarative style outweigh the drawbacks of having a few global
variables for domains like this.

But let's look at the log sink interface, because that's another good example of
how current practice is limiting statements.
#+END_NOTES

** C-Style Log Sink
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c
fprintf(g_debugLogFilep, "R Tape loading error, %d:%d", line, stmt);
#+END_SRC

What would we do if we wanted to change where the log went?

#+BEGIN_NOTES
In the 70s, we would write to stdout and change the destination with the shell
using pipes or tee. This is still perfectly fine if we're writing small console
apps, but if we're writing larger apps, we want more control. The ability to
wrangle logging options at runtime.

In the C style we'd probably encapsulate in our own function - likely one of the
v-prefixed printf functions. In OO-style?
#+END_NOTES

** Log Sinks: OO turned Declarative
#+REVEAL_HTML: <div class='vertspace2'></div>
A study in compositional design.
#+BEGIN_SRC c++
class Sink
{
  ...
  virtual bool Push(const Entry& e);
  ...
};
#+END_SRC

#+BEGIN_NOTES
A log sink takes the place of the global file pointer. It's an RAII object - on
destruction, the logger object dispatches the log entry to the sink. And it can
add entry information: a timestamp, file, line, etc (this is typically why it's
a macro).

So let's talk about log sinks, which is an example of applying declarative style
to a traditionally object-oriented approach. The key is composition.

A Sink has one important method: to push an entry. Notice it returns bool
indicating whether or not the entry was actually accepted.

With just this basic interface, we have quite a range of choices in sinks we can
make.
#+END_NOTES

** Sink Variations
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
class FileSink : Sink
{
  ...
  FileSink(string_view pathname);
  ...
};

class DebugSink : Sink { ... };
#+END_SRC

#+BEGIN_NOTES
At a basic level, we can make different sinks that go to different places. One
to a log file, one to the debug window, maybe one to a listening log aggregator
service over the network.
#+END_NOTES

** Sink Variations
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
class FilterSink : Sink
{
  ...
  template <typename Pred>
  FilterSink(Pred p);
  ...
  using Predicate = std::function<bool(const Entry&)>;
  Predicate pred;
};
#+END_SRC

#+BEGIN_NOTES
We can also make sinks that inspect the log entry and only accept certain
entries. So we can make a sink that filters entries passed to it.
#+END_NOTES

** Sink Variations
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
// Exercise for the reader: ExecutionPolicy Concept
template <typename ExecutionPolicy>
class ExecSink : Sink { ... };
#+END_SRC

#+BEGIN_NOTES
We can make a sink that wraps another sink and implements an execution policy,
so we can implement threaded logging or deferred flushing.
#+END_NOTES

** Sink Variations
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
class MultiSink : Sink
{
  ...
  vector<unique_ptr<Sink>> sinks;
};
#+END_SRC

#+BEGIN_NOTES
We can make a sink that wraps multiple other sinks and passes entries through to
them. And we can parameterize that on whether it will stop at the first
accepting sink, or fan out to all.
#+END_NOTES

** Sink Variations
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
class NullSink : Sink
{
  ...
  virtual bool Push(const Entry&) override { return true; }
  ...
};
#+END_SRC

#+BEGIN_NOTES
We can make a null sink that just returns true from Push().

What is the goal with all these variations?

Object orientation: tell, don't ask. We're encapsulating conditions using
polymorphism.
#+END_NOTES

** Declarative Sink Construction
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
auto fileSink = [&] () -> std::unique_ptr<Sink> {
  if (logToFile) {
    return std::make_unique<FileSink>(generate_filename());
  } else {
    return std::make_unique<NullSink>();
  }
}();
#+END_SRC
Conditions are encapsulated at the point of construction.

The point of use is condition-free and declarative.

#+BEGIN_NOTES
Good OO style tells us this. We use things like dependency injection and the
null object pattern - they're all about encapsulating conditions inside the
class, pushing the choice up the callstack and removing the condition from the
code that uses the object.

And of course here's an I+LE. Great for inlining short factory functions.
Unfortunately the conditional operator can't easily be used here because of the
~common_type~ requirement.

I'm using a conventional inheritance structure here to show that declarative
style is not just about value types. Of course you could use an alternative form
of polymorphism like type erasure. It wouldn't change the point here.
#+END_NOTES

** Declarative Style: Avoiding Statements
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Statement</td>
#+REVEAL_HTML: <th class="org-left">Status</td>
#+REVEAL_HTML: <th class="org-left">Killed by</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">assignment</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">guidelines</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">selection</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">paradigm shift</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">iteration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">"no raw loops"</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">jump</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-skull"></i></td>
#+REVEAL_HTML: <td class="org-left">"no raw loops"</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">declaration</td>
#+REVEAL_HTML: <td class="org-left"><i class="em em-heart"></i></td>
#+REVEAL_HTML: <td class="org-left"></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
Compositional patterns like this are the object-oriented way to avoid selection
statements.

If we want to turn off logging, we do that at the point of construction. We
don't incur the mental cost of conditions at the point of use.

"Killed by paradigm shift" sounds like a way to die in Nethack.
#+END_NOTES

* Design Patterns

** OO Patterns
#+REVEAL_HTML: <div class='vertspace2'></div>
Several patterns lean towards declarative style.

Many patterns are about replacing conditions with polymorphism.

 - Null object
 - Command
 - Composite

#+BEGIN_NOTES
These patterns have long been my favourites, but I didn't really understand why
until I started thinking about how they encourage declarative style.

The Null object pattern eliminates conditions, allowing you to write total functions.

Command reifies computation and turns behaviour into something that has a type,
that the compiler can reason about.

Composite eliminates conditions by allowing us to treat different elements of a
hierarchy the same.

These days there is one construction pattern that comes up a lot in declarative
style.
#+END_NOTES

** The "Builder Pattern"
#+REVEAL_HTML: <div class='vertspace2'></div>
AKA "Fluent Style" (not the original GoF pattern)

#+BEGIN_SRC c++
FluentGlutApp(argc, argv)
  .withDoubleBuffer().withRGBA().withAlpha().withDepth()
  .at(200, 200).across(500, 500)
  .named("My OpenGL/GLUT App")
  .create();
#+END_SRC

#+BEGIN_QUOTE
"In which the author turns what should be 5 lines of glut calls at the start of
~main~ into 100 lines of buggy OOP."
#+REVEAL_HTML: <div></div><div class='author'>
-- Nicolas Guillemot (via Twitter)
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
The wikipedia example for C++ is not compelling. This is not better than the
N lines of single-use code it replaces.

Buggy? I'm not sure. But all other things being equal, fewer lines of code are
likely to be more correct. (This isn't fewer lines of code.)

Use fluent style where it makes sense: not for single-use code. For code that
will be used a lot. For code where the verbs are few and clear. And for code
where you can make the types work for you.

I think I have better examples.
#+END_NOTES

** Builder Pattern: A Better Example
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
// Schedule& Schedule::then(interval_t);

auto s = Schedule(interval::fixed{1s})
  .then(repeat::n_times{5, interval::random_exponential{2s, 2.0}})
  .then(repeat::forever{interval::fixed{30s}});
#+END_SRC

#+BEGIN_NOTES
Building a schedule is something that happens all over the code. It's not
single-use. We've got a single verb: then. We've got types helping us out.

Fluent style encourages rvalue usage - useful when we can make it limited in
verbosity. Useful when we won't really ever need the lvalues - no reason to make
an interval other than to immediately put it in a schedule.

Readability is good. Schedules are correct by construction.
#+END_NOTES

** Builder Pattern: Help from C++17
#+REVEAL_HTML: <div class='vertspace2'></div>
P0145: Refining Expression Evaluation Order for Idiomatic C++
#+BEGIN_SRC c++
void f()
{
  std::string s = "but I have heard it works even if you don't believe in it";
  s.replace(0, 4, "")
   .replace(s.find("even"), 4, "only")
   .replace(s.find(" don't"), 6, "");
  assert(s == "I have heard it works only if you believe in it");
}
#+END_SRC

#+BEGIN_NOTES
Of course in C++17 we get extra help for using fluent-style interfaces.
Evaluation order is now specified so that this works.
#+END_NOTES

** Putting Types to Work
#+REVEAL_HTML: <div class='vertspace2'></div>
This "builder pattern" is an ideal place to put strong types to work.
#+BEGIN_SRC c++
// Build a request object
request_t req = make_request()
  .set_req_field_1(...)
  .set_req_field_2(...)
  .set_opt_field(...)
  .set_opt_field(...)
  .set_opt_field(...);

// Use it
send_request(req);
#+END_SRC

#+BEGIN_NOTES
A typical situation.

We could put the required fields in the constructor, but we might not want to
build the request all in one go.

What should ~send_request~ do with a request that accidentally doesn't have the
required fields? Today it most often will assert, or simply send the request and
get a protocol error.

What we want is for it to fail to compile.

We want to leverage a key ability of expressions over statements: they compose
on the type axis.
#+END_NOTES

** Putting Types to Work
#+REVEAL_HTML: <div class='vertspace2'></div>
The "normal" construct for this behaviour.
#+BEGIN_SRC c++
struct request_t {
  request_t& set_req_field_1(field_t f) {
    f1 = f;
    return *this;
  }
  request_t& set_req_field_2(field_t f);
  request_t& set_opt_field(field_t f);

  field_t f1;
  // etc ...
};

request_t make_request() { ... }
#+END_SRC

#+BEGIN_NOTES
What we want here is to encode the fact that the required fields have been set
(or not) in the type of the request object.

Values flow through the computation at runtime; types flow through the
computation at compile-time.

We want setting required fields to return a different type. Setting optional
fields should return the same type.

We also want setting fields to be idempotent in the type.
#+END_NOTES

** Behaviour in the Type
#+REVEAL_HTML: <div class='vertspace2'></div>
One way: use a bitfield.
#+BEGIN_SRC c++
constexpr static uint8_t OPT_FIELDS = 1 << 0;
constexpr static uint8_t REQ_FIELD1 = 1 << 1;
constexpr static uint8_t REQ_FIELD2 = 1 << 2;
constexpr static uint8_t ALL_FIELDS = OPT_FIELDS | REQ_FIELD1 | REQ_FIELD2;
#+END_SRC

#+BEGIN_NOTES
We're going to encode which fields have been set in a bitfield.
#+END_NOTES

** Behaviour in the Type
#+BEGIN_SRC c++
template <uint8_t N>
struct request_t;

template <>
struct request_t<0>
{
  field_t f1;
  // etc ...
};

template <uint8_t N>
struct request_t : request_t<N-1>
{
  request_t<N & ~REQ_FIELD1>& set_req_field1(field_t f) {
    this->f1 = f;
    return *this;
  }
  request_t<N & ~REQ_FIELD2>& set_req_field2(field_t f);
  request_t& set_opt_field(field_t f);
};
#+END_SRC

#+BEGIN_NOTES
Data members in the base class.

Clearing bits in a bitfield is idempotent. The return type of ~set_req_field_1~
might be the same as the type of the this.

Clearing bits reduces the non-type template parameter. And through recursion
everything inherits. Finally we get down to the class with only optional fields
left unset, and we can never go below that.
#+END_NOTES

** Behaviour in the Type
#+REVEAL_HTML: <div class='vertspace2'></div>
Use ~=delete~ to enable the ~send_request~ function only for a
correctly-filled-in request.
#+BEGIN_SRC c++
request_t<ALL_FIELDS> make_request();

template <uint8_t N>
void send_request(const request_t<N>& req) = delete;

void send_request(const request_t<OPT_FIELDS>& req);
#+END_SRC

#+BEGIN_NOTES
All that's left are the driver functions.

~make_request~ returns a request with all the bits set.

We have to declare, but delete ~send_request~ for the "higher level" types so
that they won't match the "lower level" overload. (Remember "higher level" types
derive from "lower level" types.)

This is nice use of types. Any non-setter functions can go in the zero
specialization. The type machinery is fairly lightweight if we only have a
couple of required fields, which is typical. No ~enable_if~, no SFINAE, correct
code results in few type instantiations. Of course everything vanishes at
runtime.

No includes! All in the language.
#+END_NOTES

** Builder Pattern Guidelines
#+REVEAL_HTML: <div class='vertspace2'></div>
 Fluent style is more suitable when:

 - you have a single verb (~then~, ~set_field~)
 - you'll be building objects a lot
 - you can make types work for you
 - rvalues aren't too verbose

#+BEGIN_NOTES
Don't use for single use. You'll be writing more code to do the same job.

Single verb, or few verbs: you don't want a huge builder interface - this also
mitigates the amount of code. You want the code to be obviously correct.
#+END_NOTES

* Ranges
#+REVEAL_HTML: <div class='vertspace2'></div>
Let's talk about ranges a little.

#+BEGIN_NOTES
Ranges offer the chance for a new leverage of declarative style.
#+END_NOTES

** Ranges: Example 0
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
dates_in_year(2015)    // 0. Make a range of dates.
  | by_month()         // 1. Group the dates by month.
  | layout_months()    // 2. Format the month into a range of
                       //    strings.
  | chunk(3)           // 3. Group the months that belong
                       //    side-by-side.
  | transpose_months() // 4. Transpose the rows and columns
                       //    of the side-by-side months.
  | view::join         // 5. Ungroup the side-by-side months.
  | join_months()      // 6. Join the string of the transposed
                       //    months.
#+END_SRC

#+BEGIN_NOTES
From Eric's 2015 C++Now/CppCon talk "Ranges for the Standard Library".

This is one expression. Eric said: Composable. Lots of parts are reusable. It
works with infinite ranges. Can show N months side-by-side (3 chosen).

No Loops!!! (with 3 exclamation marks). But he went over that point very
quickly. Perhaps it was a throwaway reference to Sean's work. But he didn't
emphasize why no loops was important. (No statements!)

Correct by construction. We don't have to do much to convince ourselves that
it's correct. It's built that way.
#+END_NOTES

** Ranges: Example N
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
  std::mt19937 gen(std::random_device{}());
  auto rsvps = rsvp_json                           // json is a valid range
    | view::remove_if([](auto&& elem) {
          return "yes" != elem.at("response"); })  // filter out non-"yes" RSVP responses
    | view::transform([](auto&& elem) {
          return elem["member"]["name"].dump(); }) // keep name as string
    | ranges::to_vector                            // convert lazy range to vector
    | action::shuffle(gen);                        // random shuffle vector elements

#+END_SRC
From https://github.com/CoreCppIL/raffle

#+BEGIN_NOTES
This from the Core C++ Israel user group. It's the code they use to randomly
pick from meetup.com RSVPs. This is only part of the code but the whole of the
code is designed to fit on one slide.

Once again this whole thing is a composition of two declarations and lots of
expressions.
#+END_NOTES

** Ranges: Readability is Familiarity
#+REVEAL_HTML: <div class='vertspace2'></div>

What does this do?

#+BEGIN_SRC apl
+\⍳10
#+END_SRC

#+BEGIN_NOTES
This is probably not familiar to you.

Who knows what language this is?

Yes, that's a greek letter.
#+END_NOTES

** Ranges: Readability is Familiarity
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
int arr[] = {1,2,3,4,5,6,7,8,9,10};
int sum = 0;
for (int i = 0; i < 10; ++i)
{
  sum += arr[i];
  arr[i] = sum;
}
#+END_SRC

#+BEGIN_NOTES
Is this code correct?

What is the performance?

How sure are you? How long do you need to look at this code to know what it
does?

How likely is this code to retain its properties?
#+END_NOTES

** Ranges: Readability is Familiarity
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
std::array<int, 10> input;
std::iota(input.begin(), input.end(), 1);
std::partial_sum(input.begin(), input.end(), input.begin());
#+END_SRC

#+BEGIN_NOTES
Is this code correct? (You may have to look up whether ~partial_sum~ allows
"overwriting" of the range - it's not obvious.

What is the performance?

How sure are you? How long do you need to look at this code to know what it
does?

How likely is this code to retain its properties?
#+END_NOTES

** Ranges: Readability is Familiarity
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC apl
+\⍳10
#+END_SRC
#+BEGIN_SRC c++
auto r = view::iota(1)
       | view::take(10)
       | view::partial_sum(std::plus<>{});
#+END_SRC

#+BEGIN_NOTES
We can be pretty sure this is correct.

It is likely to remain correct. It's actually still correct if we change the
order of ~partial_sum~ and ~take~.

You have to put some trust in the implementer of the functions. But "view" is a
good sign that these things don't take up a lot of space and only hold exactly
what they need to advance.
#+END_NOTES

** Readable & Robust
#+REVEAL_HTML: <div class='vertspace2'></div>
Code that says WHAT is just as readable as code that says HOW.

We are used to seeing code that says HOW. It's more familiar.

Code that says WHAT is more likely to remain robust.

#+BEGIN_NOTES
I would say MORE readable.
#+END_NOTES

** "Wholemeal Programming"
#+REVEAL_HTML: <div class='vertspace2'></div>
Declarative style is about processing data pipelines.

When you have composable pieces, rearranging and exploring data is quick and
easy.

Compare: unix command-line.
#+ATTR_REVEAL: :frag (appear)
 - generators (find, ~iota~)
 - selections (grep, ~unique~)
 - transformations (cut, tr, ~transform~)
 - permutations (sort, ~shuffle~)
 - reductions/unfolds (wc, xargs, ~accumulate~)

#+BEGIN_NOTES
What's the point here? These are very easy to string together, so that they
support exploratory work.

Combos of these where convenient, e.g. ~chunk~.

In functional circles this is sometimes called "Wholemeal programming" as
distinct from the "piecemeal programming" of imperative loops and conditions.
#+END_NOTES

* Operator Overloading
#+REVEAL_HTML: <div class='vertspace2'></div>
Good or bad?

#+ATTR_REVEAL: :frag (appear)
Answer: good. When principled.

#+BEGIN_NOTES
Don't know if you've noticed, but we've seen a lot of code that uses operators.
Ranges, tests, logging.

Declarative style relies on composition and expressions, so operators are
important. But operator overloading gets a lot of bad press.

It seems to be viewed as something that is easily abused and rarely used to good
effect. I want to tell you why I think it's really good and offer some
principles.
#+END_NOTES

** Expressive user-defined types
#+REVEAL_HTML: <div class='vertspace2'></div>
Regular types are great!

Operators give us compositional style with concision.

#+BEGIN_SRC c++
// which would you rather see?

// option 1
a = operator+(x, operator*(y, z));

// option 2
a = x + y * z;
#+END_SRC

#+BEGIN_NOTES
Potentially huge readability gain here.

Let's explore the boundaries a bit.
#+END_NOTES

** Command-Line Parsing: Clara
#+REVEAL_HTML: <div class='vertspace2'></div>
Phil Nash: /A Composable Command Line Parser/

(CppCon 2017 Lightning Talks)
#+BEGIN_SRC c++
auto cli
  = ExeName( config.processName )
  | Help( config.showHelp )
  | Opt( config.listTests )
      ["-l"]["--list-tests"]
      ( "list all/matching test cases" )
  | Opt( config.listTags )
      ["-t"]["--list-tags"]
      ( "list all/matching tags" )
  ...
#+END_SRC
https://www.youtube.com/watch?v=Od4bjLfwI-A

#+BEGIN_NOTES
This is originally from Catch. A good example of operator overloading.

I recommend watching Phil's talk. I think the key is starting with
composability. This inevitable leads you towards unlocking a declarative style.

Here again we can see hallmarks of declarative style:
 - use of expressions
 - overloading operators
 - of course, declaration

This code says WHAT very clearly. It doesn't say HOW. It doesn't CARE HOW.
#+END_NOTES

** Operator overloading advice
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag appear
#+BEGIN_QUOTE
#+REVEAL_HTML: <p>"When in doubt, do as the <code>int</code>s do."</p>
#+REVEAL_HTML: <div></div><div class='author'>
-- Scott Meyers, /More Effective C++/
#+REVEAL_HTML: </div>
#+END_QUOTE
#+REVEAL_HTML: <br clear="all"/>
#+ATTR_REVEAL: :frag appear
#+BEGIN_QUOTE
"It is probably wise to use operator overloading primarily to mimic conventional
use of operators."
#+REVEAL_HTML: <div></div><div class='author'>
-- Bjarne Stroustrup, /The C++ Programming Language/
#+REVEAL_HTML: </div>
#+END_QUOTE
#+REVEAL_HTML: <br clear="all"/>
#+ATTR_REVEAL: :frag appear

#+BEGIN_NOTES
Arguments against operator overloading:

People don't like re-using operators to mean arbitrary, nonconventional things.
(cf trademarks)

People don't like the potential for operators to impose performance costs
through hidden computation and through binary functions calls rather than n-ary.
#+END_NOTES

** Operator overloading
#+REVEAL_HTML: <div class='vertspace2'></div>
When in doubt, do what ~operator+~ does?

#+BEGIN_NOTES
Maybe we should try to find the most "normal" operator and see if we can divine
some guidelines for overloading.
#+END_NOTES

** ~operator+~ Properties
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Property</td>
#+REVEAL_HTML: <th class="org-left">Math(s)</td>
#+REVEAL_HTML: <th class="org-left">C++</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="1">Closed</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="1">&#x2714;</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="5">&#x2717; (overflow)</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="2">Associative</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="2">&#x2714;</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="6">&#x2717; (floating point)</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="3">Commutative</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="3">&#x2714;</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="7">&#x2717; (strings)</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="4">Has Identity</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="4">&#x2714;</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="8" style="float: inline-start;">&#x2714;</div><div class="fragment" data-fragment-index="13">&#x2714;(+0.0, -0.0!)</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
This tells me that programming has its own conventions separate from the
conventions of mathematics.

On the other hand, we do try to follow mathematical conventions mostly.

In C++, equality is an equivalence relation. Unlike in Javascript.
#+END_NOTES

** C++ Operator Conventions
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Operator(s)</td>
#+REVEAL_HTML: <th class="org-left">Convention</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="1"><code>==</code>  <code>!=</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="2">Math(s)-like</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="3"><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;=&gt;</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="4">Math(s)-like</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="5"><code>+</code> <code>-</code> <code>*</code> <code>/</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="6"><em>Mostly</em> math(s)-like</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="7"><code>|</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="8">Pipelining, monoidal</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="9"><code>-&gt;*</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="10">Expression templates</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="11"><code>&amp;&amp;</code> <code>||</code> <code>,</code></div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="12">Just don't</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="13">other</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="13">Open for abuse?</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+BEGIN_NOTES
I like to use unary+ as "conversion to underlying type" on my scoped enums.

Overloaded / for path concat is reasonably defensible.
#+END_NOTES

** Operators in Compiler History
(from https://jeffreykegler.github.io/personal/timeline_v3)
#+REVEAL_HTML: <div class='vertspace2'></div>
1956: The IT Compiler
#+ATTR_REVEAL: :frag appear
#+BEGIN_QUOTE
"...the first really /useful/ compiler."
#+REVEAL_HTML: <div></div><div class='author'>
-- Donald E Knuth
#+REVEAL_HTML: </div>
#+END_QUOTE

#+REVEAL_HTML: <br/>
#+ATTR_REVEAL: :frag appear
But it didn't have operator precedence as we know it today.
#+ATTR_REVEAL: :frag appear
#+BEGIN_QUOTE
"The lack of operator priority ... in the IT language was the most frequent
single cause of errors by the users of that compiler."
#+REVEAL_HTML: <div></div><div class='author'>
-- Donald E Knuth
#+REVEAL_HTML: </div>
#+END_QUOTE

#+BEGIN_NOTES
IT (Internal Translator) was a compiler for the IBM 650. Perhaps the first
compiler that we would recognize as one in the modern sense.
#+END_NOTES

** Operator overloading learnings
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 - operators communicate properties
 - operators make sense for binary functions
 - operators should be conventional
 - identify your monoids!

#+BEGIN_NOTES
Infix notation conveys properties more naturally?
Commutativity, Associativity, Closedness.

Infix expressions are more malleable, easier to move around, compose, use parens
to clarify, etc.

Compilers can't collapse n functions calls into an n-ary function call. Where
binary functions are the main/only way to compose your types, overloading
operators can make a lot of sense.

Shorter = more readable.

We get to define our own conventions -- no need for dogmatic reliance on maths.
#+END_NOTES

* Where can we go from here?
#+REVEAL_HTML: <div class='vertspace2'></div>
Where is C++ giving declarative code good support?

Where can it be improved?

* Where C++ is Strong

** RAII, Initialization
#+REVEAL_HTML: <div class='vertspace2'></div>
RAII is the bread-and-butter of C++ programming. It's a natural fit for a
declarative style.

Initialization is complex, but getting easier.
 * aggregate initialization
 * rule of zero
 * UDLs for extra expressiveness
 - class template deduction
 - C++20 designators

#+BEGIN_NOTES
Obviously, RAII is all about declaring something and letting the C++ machinery
take care of lifetime. We love it - it's what C++ is about.

Initialization is one of those areas of C++ that has been getting a lot of
scrutiny, a fair amount of "bad press" highlighting where it's not good enough
yet, so it's moving pretty strongly.
#+END_NOTES

** Functions & lambdas
#+REVEAL_HTML: <div class='vertspace2'></div>
Functions:
 * turn statements into expressions
 * give expressions names
 * encapsulate conditions
 * are the optimizer's bread and butter

Structured bindings work around single-return-value limitation.

#+BEGIN_NOTES
Functions are wonderful. Higher order functions are in some sense the FP
equivalent of OO's dependency injection.

Structured bindings allow multiple "atomic" declarations.

We think about these often in the context of ~if~-initialization, and they do go
well together, but if you're generally trying to avoid conditions,
~if~-initialization might become less important.

But the principle of useful return is important.

See also: no raw loops.
#+END_NOTES

** Overloads & templates
#+REVEAL_HTML: <div class='vertspace2'></div>
Parametric polymorphism: enable use of functions without conditionals.

Let the compiler do the right thing.
#+BEGIN_SRC c++
template <typename A, typename B = A,
          typename C = std::common_type_t<A, B>,
          typename D = std::uniform_int_distribution<C>>
inline auto make_uniform_distribution(const A& a,
                                      const B& b = std::numeric_limits<B>::max())
  -> std::enable_if_t<std::is_integral_v<C>, D>
{
  return D(a, b);
}
#+END_SRC
Andy Bond: /AAAARGH!?/ (CppCon 2016)

https://www.youtube.com/watch?v=ZCGyvPDM0YY

#+BEGIN_NOTES
Adopting Almost-Always-Auto Reinforces Good Habits?
#+END_NOTES

** Overloads & templates
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
template <typename A, typename B = A,
          typename C = std::common_type_t<A, B>,
          typename D = std::uniform_real_distribution<C>>
inline auto make_uniform_distribution(const A& a,
                                      const B& b = B{1})
  -> std::enable_if_t<std::is_floating_point_v<C>, D>;

class uniform_duration_distribution;

template <typename A, typename B = A,
          typename C = std::common_type_t<A, B>,
          typename D = uniform_duration_distribution<C>>
inline auto make_uniform_distribution(const A& a,
                                      const B& b = B::max()) -> D;
#+END_SRC

#+BEGIN_NOTES
With relatively little effort, we can make a type-safe uniform distribution for
chrono durations. Really useful for improving call sites and unlocking the
ability for users to be type-safe.

I use this all the time in my day job for implementing randomized network
backoffs.
#+END_NOTES

** Other features
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 * Guaranteed copy elision P0135
 * Evaluation order guarantees P0145
 * Fold expressions

#+BEGIN_NOTES
Guaranteed copy elision: obviously really good for leveraging functions.

Evaluation order guarantees are great for the builder pattern we saw earlier.

I haven't even mentioned fold expressions. They offer increased flexibility of
interface and the chance to get n-ary application for free with a simple binary
function interface. They magnify the power of operator overloading.
#+END_NOTES

* Where C++ is weaker
#+REVEAL_HTML: <div class='vertspace2'></div>
AKA: write a paper!

C++Now is a good place to start...

** Inconsistencies
#+REVEAL_HTML: <div class='vertspace2'></div>
In C++17, we gained ~if~- and ~switch~-initializers.
#+BEGIN_SRC c++
if (auto [it, inserted] = m.emplace("Jenny", 8675309); inserted)
{
  ...
}
#+END_SRC
But no love for the expression equivalent of ~if~.
#+BEGIN_SRC c++
auto result =
  (auto [it, inserted] = m.emplace("Jenny", 8675309); inserted)
  ? // some expression ...
  : // some other expression ...
#+END_SRC

#+BEGIN_NOTES
~if~ and the conditional operator ostensibly do the same thing, but not really.

Partly because ~if~ is a statement and doesn't need to obey the rules of the
type system in its two branches.
#+END_NOTES

** Heritage: assignment
#+REVEAL_HTML: <div class='vertspace2'></div>
Assignment is an expression.
 * implementation burden: lvalues
 * ~operator=~ must be a member function
 * but ~operator@=~ can be free?
 * chained assignments? convenient but a smell

Assignment is blurred with construction.
 * historic: rule of N
 * conflicting sink parameter advice
 * now it's worse: move vs copy, reference qualifiers

#+BEGIN_NOTES
Assignment operator "has to" return lvalue ref.

Remember the previous quote from The C++ Prog lang: "It cannot be overemphasized
that /assignment and initialization are different operations/."

Example from The C++ Programming Language: "The definition of ~operator+=~ for
~complex~ cannot be deduced from the definitions of ~operator+~ and ~operator=~.

But in practice, anyone deviating from the semantics would receive short shrift
in a code review.
#+END_NOTES

** Legacy type system: "functions"
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
int steps = 0;
auto f = [&](int x) { ++steps; return x / 2; };
auto g = [&](int x) { ++steps; return 3 * x + 1; };

// why doesn't this work?
auto h = (x % 2 == 0) ? f : g;
#+END_SRC

#+BEGIN_NOTES
Of course, we know why it doesn't work. It doesn't work because we don't have
proper function types (which is to say, function signature types) in the
language. We have functions, function pointers, PMFs, PMDs, lambdas, bind
expressions...

We have reference-qualifiers, const, volatile, constexpr, noexcept, even
abominable function types. But for all that power we don't have a simple way in
the language to use or express type-equality in terms of a function's signature.
#+END_NOTES

** Heritage: operators
#+REVEAL_HTML: <div class='vertspace2'></div>
C++ inherits pretty much all of its operators from C.

We also inherit some fixed semantics (despite operator overloading).

Operators can be amazing for expressivity of code and declarative constructs.

#+BEGIN_NOTES
Operators have a huge potential for expressing declarative code.

Unfortunately C++ operators are one of parts of the language that gets the least
attention.
#+END_NOTES

** Heritage: operators
#+REVEAL_HTML: <div class='vertspace2'></div>
Operators are hard to deal with in C++.

#+ATTR_REVEAL: :frag (appear)
 * fixed syntactic set
 * fixed precedence
 * fixed associativity
 * fixed arity
 * fixed fixity
 * fixed evaluation semantics (which may change on overload)
 * ADL

#+BEGIN_NOTES
No wonder overloading operators is such an unloved part of the language. No
wonder operator overloading is frowned upon in many circles. We can't make them
mean what they should. We can't make them do what they should. We can't make
them very easy to use. So a lot of people look at operator overloading as syntax
abuse.

You get to use operator overloading pretty much if you're concatenating
string-like things, or writing a "numeric" class like a matrix, or providing a
way to print your type.

I would love to see some of these shortcomings tackled. Many of these things are
"language rules" that could be expressed in code. Can we do for operators what
metaclasses do for user defined types?
#+END_NOTES

** Operator Overloading and Futures
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <img src='futures.svg'/>
#+BEGIN_SRC c++
// imaginary-ish code
my_future<A> f(X);
my_future<B> g1(A);
my_future<C> g2(A);
my_future<D> h(B, C);
#+END_SRC

#+BEGIN_NOTES
Imagine a simple composition of asynchronous functions that return futures.

Notice that their composition can itself be viewed as a function from X to
future<D>.

I'm not making any assumptions about how ~my_future~ is implemented here.
#+END_NOTES

** Operator Overloading and Futures
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC c++
auto fut = f();
auto split1 = fut.then(g1);
auto split2 = fut.then(g2);
auto fut2 = when_all(split1, split2).then(h);
#+END_SRC
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC c++
auto fut = f() > (g1 & g2) > h;
#+END_SRC
#+ATTR_REVEAL: :frag appear
Operator overloading can clarify the computational structure when combining
futures/promises.

#+BEGIN_NOTES
When we can use operators to compose futures, it becomes easier to see the
computational structure of the composition.

Business logic vs mechanism of concurrency vs strategy of parallelism.

The question is, what to use for an operator. This is one of the real problems
with operator overloading: lack of choice almost forces lack of conventionality.
#+END_NOTES

** A call to action
#+REVEAL_HTML: <div class='vertspace2'></div>
What convention are we going to adopt for monadic operators?

The future for ~future~ operators is uncertain.

Please, let's not abuse more operators like we did with ~>>~ and ~<<~ for
streams.

#+BEGIN_NOTES
There is a lot potentially on the table here. We're missing a lot of
expressivity in new areas, especially involving composition of monoidal and
monadic types, because we lack the power in overloading operators.
#+END_NOTES

* Where C++ is getting better

** "Imperative safety gear"
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 * better warnings
 * static analysis
 * ~[[nodiscard]]~ attribute (another default?)
 * ~[[fallthrough]]~ attribute
 * ~if~-initializer

#+BEGIN_NOTES
We're starting to get the ability for "compilers" to help us reason about
statement sequencing. And to avoid some of the obvious historical errors.

~nodiscard~ on types would prevent the unnamed lock issue.

Experiment: use ~nodiscard~ on every function! Is it another "wrong way round
default"?
#+END_NOTES

** Heritage: Declaration Syntax
#+REVEAL_HTML: <div class='vertspace2'></div>
Something we're too close to to appreciate how painful it is?
#+BEGIN_SRC c
int (*daytab)[13];
int *daytab[13];

char (*(*x[3])())[5];
#+END_SRC

K&R: /5.12 Complicated Declarations/

#+BEGIN_QUOTE
"C is sometimes castigated for the syntax of its declarations, particularly ones
that involve pointers to functions."
#+END_QUOTE
#+BEGIN_QUOTE
"...because declarations cannot be read left-to-right, and because parentheses
are over-used."
#+END_QUOTE

#+BEGIN_NOTES
I'm not knocking C here. This was fine in 1972!
#+END_NOTES

** Declaration Syntax Help
#+REVEAL_HTML: <div class='vertspace2'></div>
Prefer ~using~ over ~typedef~.

Prefer trailing return syntax in aliases.

Think of ~auto(*)~ as a token that means "pointer-to-function".

#+BEGIN_SRC c++
typedef int (*FP)(float, string);

using FP = auto(*) (float, string) -> int;
#+END_SRC

** Richness of library help
#+REVEAL_HTML: <div class='vertspace2'></div>
Seemingly-unimportant helper functions (or metafunctions) can be very important
in avoiding conditionals.

#+ATTR_REVEAL: :frag (appear)
 * ~std::exchange~
 * ~std::as_const~
 * ~std::apply~
 * expanding ~type_traits~
 * monadic interface to ~std::optional~

#+BEGIN_NOTES
I love ~std::exchange~ - one of the most underappreciated functions in the STL.

When you start trying to deliberately limit use of statements and program more
declaratively, the use for these types of functions becomes more apparent.
#+END_NOTES

** Richness of library help
#+REVEAL_HTML: <div class='vertspace2'></div>
#+BEGIN_SRC c++
template <typename T>
decltype(auto) identity(T&& t) {
  return std::forward<T>(t);
}
#+END_SRC

#+BEGIN_SRC c++
template <typename T>
auto always(T&& t) {
  return [x = std::forward<T>(t)](auto...) { return x; };
};
#+END_SRC

#+BEGIN_NOTES
These are examples of a couple functions that exist in functional languages.
Again, the use of them isn't obvious to non-declarative programmers. Often the
use lies in getting rid of conditionals.

std::identity was in the original SGI STL.

If you do TMP, you're probably used to the idea of needing these kinds of
metafunctions. TMP doesn't have assignment, so it's by nature a lot more
declarative. ~common_type_t~ with a single argument is often used as the
identity function.
#+END_NOTES

* Guidelines for Declarative Code
#+REVEAL_HTML: <div class='vertspace2'></div>

Meta-guideline /reductio/: avoid writing statements.

(Principally control-flow and assignment.)

** Replacing Conditionals
#+REVEAL_HTML: <div class='vertspace2'></div>
#+REVEAL_HTML: <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <th class="org-left">Style</td>
#+REVEAL_HTML: <th class="org-left">Signature Element</td>
#+REVEAL_HTML: <th class="org-left">Elimination Strategy</td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">Imperative</td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="1">Statement</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="2">multi-computation</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">Object-Oriented</td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="3">Object construction</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="4">polymorphism</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">Functional</td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="5">Function call</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="6">higher order function</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: <tr>
#+REVEAL_HTML: <td class="org-left">Generic</td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="7">Type instantiation</div></td>
#+REVEAL_HTML: <td class="org-left"><div class="fragment" data-fragment-index="8">traits class</div></td>
#+REVEAL_HTML: </tr>
#+REVEAL_HTML: </tbody>
#+REVEAL_HTML: </table>

#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag appear :frag_idx 9
The Conditional-Replacement Meta-Pattern.

#+BEGIN_NOTES
 - fsel intrinsic on XBox 360
 - null object pattern
 - std::sort comparator
 - ~pointer_traits~

This metapattern unlocks composition in all these cases. Because it turns
statements into expressions suitable for the domain.
#+END_NOTES

** Replacing Conditionals
#+REVEAL_HTML: <div class='vertspace2'></div>
#+ATTR_REVEAL: :frag (appear)
 - Push conditionals down the callstack
   - intrinsic to data structures
   - optional/monadic interface
   - handle at leaf, don't leak
 - Push conditionals up the callstack
   - dependency injection
   - higher-order functions
   - power to the caller
   - lifted to root, abstracted
 - Goal: total functions

#+BEGIN_NOTES
Conditions get eliminated, or get pushed up or down the call stack. Pushing down
the call stack encapsulates conditions when there is some intrinsic property of
the data structure that is a condition (like optionality). Pushing up the call
stack and replacing with a behaviour that is passed in gives control to the
caller while keeping the call site declarative.

Another way to say it: treat conditionals like we treat errors: handle them and
encapsulate them at the leaf. Or push them up to the root and abstract the
condition in a construct that makes sense for your programming paradigm.
#+END_NOTES

** Replacing conditionals => fewer statements
#+REVEAL_HTML: <div class='vertspace2'></div>
When you replace/encapsulate conditionals:
 - less call-site logic (obviously)
 - simpler, total functions
 - simpler loops (no break/continue without conditions)
 - more reason-ability

#+BEGIN_NOTES
Fewer conditions in business logic. Total functions.
#+END_NOTES

** Replacing loops => fewer statements
#+REVEAL_HTML: <div class='vertspace2'></div>
No Raw Loops: encapsulate and replace iteration and jumps
 - less call-site logic
 - simpler, total functions
 - more reason-ability
 - vocabulary grows

#+BEGIN_NOTES
You're used to "no raw loops". Algorithms are functions with all the goodness of
functions.

Algorithms lock up the statements and reduce the call-site complexity. They work
with edge cases. They have names.
#+END_NOTES

** Replacing assignments
#+REVEAL_HTML: <div class='vertspace2'></div>
 - Declare-at-use
   - use I+LEs
   - leverage ~const~
   - use AAA-style if you like
 - Overload operators for declaration power

#+BEGIN_NOTES
 * Use I+LEs where appropriate for initialization
 * Leverage the power of ~return~
 - Operator overloading can be great and can communicate things about your types
   that are otherwise hidden
#+END_NOTES

** Let the language help
#+REVEAL_HTML: <div class='vertspace2'></div>
Where you can't avoid statements, use "imperative safety gear"
 - ~nodiscard~ attribute
 - ~if~-initializer
 - static analysis

#+BEGIN_NOTES
C++ is multiparadigm. Don't let declarative style be your only hammer, except as
an exercise in discovery.

Imperative safety gear is great. And if you can find a way not to need it,
that's great too.
#+END_NOTES

** Declarative Interfaces
#+REVEAL_HTML: <div class='vertspace2'></div>
 - dependency injection
 - higher-order functions
 - builder pattern / fluent style
 - identify monoids
 - start with composition

#+BEGIN_NOTES
 - Let callers encapsulate conditions, abstract choices
 * Consider builder/fluent-style with the earlier guidelines
 * Identify monoids - this will inform operator overloading and lead you to an
   easy-to-use, compositional style
#+END_NOTES

** Declarative Goals
#+REVEAL_HTML: <div class='vertspace2'></div>
Expressions over statements.

Declarations over assignments.

Unconditional code.

* Notes                                                            :noexport:
