<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Easy to Use, Hard to Misuse</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<link rel="stylesheet" href="./emoji.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><div class='vertspace6'/><h3>Easy to Use, Hard to Misuse</h3><h2>Declarative Style in C++</h2></div><h3>Ben Deane / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h4>CppCon / Friday September 28th, 2018</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org0728b00">
<h2 id="org0728b00">In This Talk</h2>
<div class='vertspace2'></div>
<ol>
<li>Definitions &amp; motivation</li>
<li>Where we came from</li>
<li>Where we are</li>
<li>Where we could be headed</li>

</ol>

<aside class="notes">
<p>
I'm going to try to look at the history of programming and C++ and the current
practices that exist, and I'm going to look through a declarative lens.
</p>

<p>
The goal is to see how to apply declarative programming principles to make our
C++ better, in the context of this large, multiparadigm language that isn't
necessarily always amenable to naive pure functional declarative techniques.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org877a5f7">
<h2 id="org877a5f7">What Do We Mean?</h2>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"A programming paradigm &#x2026; that expresses the logic of a computation without
describing its control flow."
</p>
<div></div><div class='author'>
<p>
&#x2013; Declarative programming page on Wikipedia
</p>
</div>
</blockquote>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"Often it involves the separation of 'facts' from operations on the facts."
"&#x2026; generalizes the pure functional model."
</p>
<div></div><div class='author'>
<p>
&#x2013; wiki.c2.com
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Removing control flow complexity is an important idea.
</p>

<p>
Order of statements should not affect semantics. (Lack of internal/temporal dependencies)
</p>

<p>
Replication of statements should not affect semantics. (Idempotency)
</p>

<p>
These ideas are key to the promise of declarative style: when we write in a
declarative style, it's often easier to convince ourselves that the code is
correct. And we'll see examples of that.
</p>

</aside>

</section>
<section id="slide-org49e496b">
<h3 id="org49e496b">Language Classifications?</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">imperative/procedural (FORTRAN, C)</li>
<li class="fragment appear">object-oriented (Smalltalk, Java)</li>
<li class="fragment appear">functional (ML, Haskell)</li>
<li class="fragment appear">etc.</li>

</ul>

<aside class="notes">
<p>
Many general-purpose languages (certainly of the last 30-40 years) resist strict
classification.
</p>

<p>
If a language is general purpose enough to be widely useful, it's likely that it
doesn't fit neatly into a single category. Most large languages allow multiple
techniques in programming.
</p>

<p>
And we would say that C++ is multiparadigm of course. Procedural, OO,
functional, generic at least.
</p>

</aside>

</section>
<section id="slide-org65192ff">
<h3 id="org65192ff">Declarative Style Indicators</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">referential transparency</li>
<li class="fragment appear">say WHAT in preference to HOW</li>
<li class="fragment appear">minimize imperative style</li>
<li class="fragment appear">declaring things</li>
<li class="fragment appear">expressions over statements</li>

</ul>

<aside class="notes">
<p>
Declarative style is not a hard-and-fast thing, especially not in C++. It's
rather a way of tailoring the code.
</p>

<p>
It's about a preference of style in the service of reason-ability. At the risk
of being etymologically reductive, in part it's a preference for using
declarations.
</p>

<p>
Next: Expressions vs Statements
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga39cf93">
<h2 id="orga39cf93">Expressions vs Statements</h2>
<aside class="notes">
<p>
Let's compare and contrast and see what we can discover.
</p>

<p>
What does the standard say?
</p>

</aside>

</section>
<section id="slide-orge055fa0">
<h3 id="orge055fa0">Expressions</h3>
<div class='vertspace2'></div>
<p>
"An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side effects." [expr.pre] &sect; 1
</p>
<div class='vertspace2'></div>
<p>
Properties of expressions:
</p>
<ul>
<li class="fragment appear">value category</li>
<li class="fragment appear">type</li>

</ul>

<aside class="notes">
<p>
The standard has a lot to say about expressions in general before even going
into detail about kinds of expressions and how to make them.
</p>

<p>
There is the familiar value-category tree (lvalue, xvalue, prvalue, etc), which
has "expression" at its root.
</p>

<p>
Expressions have intrinsic properties that can be reasoned about.
</p>

<p>
There is also "context dependence" which is to do with unevaluated contexts and
evaluation for side effects only. A bit of standardese, really.
</p>

</aside>

</section>
<section id="slide-org98d784f">
<h3 id="org98d784f">Expressions Compose On Multiple Axes</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">expr</span> = a @ b @ c;
</pre>
</div>
<div class='vertspace2'></div>
<p>
Consider this snippet.
</p>

<p>
(@ stands for any operator)
</p>

<aside class="notes">
<p>
There are at least two obvious kinds of composition going on here.
</p>

<p>
a, b, and c have values. expr has a value.
</p>

<p>
a, b, and c have types. expr has a type.
</p>

<p>
Expressions compose on the value axis, and also on the type axis.
Value-composition happens at runtime, and type composition happens at
compile-time. So it can be checked.
</p>

</aside>

</section>
<section id="slide-orgfb18aff">
<h3 id="orgfb18aff">Statements</h3>
<div class='vertspace2'></div>
<p>
"Except as indicated, statements are executed in sequence." [stmt.stmt] &sect; 1
</p>
<div class='vertspace2'></div>
<p>
Properties of statements:
</p>
<ul>
<li class="fragment appear">er&#x2026;</li>

</ul>

<aside class="notes">
<p>
The standard doesn't have a lot to say about statements in general. They are
defined extrinsically, simply by enumerating the different kinds of statements
that we can write.
</p>

<p>
There are no real intrinsic properties of statements.
</p>

</aside>

</section>
<section id="slide-org2351b42">
<h3 id="org2351b42">Statements "Compose" Only By Sequencing</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++">x;
y;
z;
</pre>
</div>
<ul>
<li>no type checking</li>
<li>value checking is manual, intrusive</li>
<li>implicit constraints</li>
<li>temporal reasoning is poor</li>

</ul>

<aside class="notes">
<p>
Statements "compose" only by sequencing. There is no direct way to constrain this.
No type checking.
</p>

<p>
Some value checking is done with asserts. I say intrusive because assert itself
is a statement; asserting expressions doesn't change the expressions, but
asserting statements changes the flow of statements.
</p>

<p>
We have (varyingly implicit) constraints with pre- and post-conditions, and
variable lifetime extents. We use variable scoping to control things.
</p>

<p>
Dijkstra: "Our intellectual powers are rather geared to master static relations
and our powers to visualize processes evolving in time are relatively poorly
developed."
</p>

<p>
Carmack: "A large fraction of the flaws in software development are due to
programmers not fully understanding all the possible states their code may
execute in."
</p>

</aside>

</section>
<section id="slide-orgf1bb863">
<h3 id="orgf1bb863">Imperative Safety Gear</h3>
<div class='vertspace2'></div>
<p>
Many of our guidelines, best practices, idioms, and much of our tooling,
analysis, and brainpower work in service of checking the implicit constraints
around statement "composition".
</p>

<aside class="notes">
<p>
We put a lot of effort into controlling statements!
</p>

<p>
We make conventions. We make guidelines.
</p>

<p>
We make tools. We like to run multiple static analysers to get different
benefits from each.
</p>

<p>
We make more tools. We make libraries in support of those tools. We add things
to the language (like contracts) to help us manage this problem. There are great
minds working to bring formal reasoning to statement flow.
</p>

<p>
This is all well and good, but here's an alternative: use fewer statements and
more expressions.
</p>

</aside>

</section>
<section id="slide-org90aa32e">
<h3 id="org90aa32e">Declarative Style: Avoid Statements!</h3>
<div class='vertspace2'></div>
<ul>
<li>expression statement</li>
<li>selection statement (<code>if</code>, <code>switch</code>)</li>
<li>iteration statement (<code>for</code>, <code>while</code>, <code>do</code>)</li>
<li>jump statement (<code>break</code>, <code>continue</code>, <code>return</code>, <code>goto</code>)</li>
<li>declaration statement</li>

</ul>

<aside class="notes">
<p>
Declarative style is essentially a preference for avoiding statements.
</p>

<p>
Here are the statements available to us. (For the language lawyers, I left out
compound statements (if we get rid of other statements, we mostly get rid of
them), try blocks and atomic/synchronized blocks from the TM TS.) Only the last
of these (declaration statement) is good.
</p>

<p>
As a goal, we should try to avoid most of the rest where we can. It's not a
hard-and-fast rule; it's a goal.
</p>

<p>
Avoiding statements may sound odd at first. But I hope to show that when we look
at current practice through this lens, we'll see that it's what we're already
doing, even if we don't realise it.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga72e367">
<h2 id="orga72e367">Let's Examine History&#x2026;</h2>
<div class='vertspace2'></div>
<p>
Let's look at where we've come from, and see how it informs moving to
declarative style.
</p>

<aside class="notes">
<p>
Let's look first at expression statements.
</p>

<p>
The easiest target.
</p>

<p>
"Most statements in a typical C++ program are expression statements, such as
assignments or function calls." &#x2013; cppreference.com
</p>

</aside>

</section>
<section id="slide-org72b98d3">
<h3 id="org72b98d3">World's Last Bug</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #a020f0;">while</span> <span style="color: #707183;">(</span><span style="color: #008b8b;">true</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  status = GetRadarInfo<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>status = <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>
    LaunchMissiles<span style="color: #7388d6;">()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Ancient history you say?
</p>

<aside class="notes">
<p>
Assignment is the king of expression statements.
</p>

<p>
Two odd things here. Let's digress a bit and consider how history brought us to
the current situation.
</p>

</aside>

</section>
<section id="slide-orga7f6eb4">
<h3 id="orga7f6eb4">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<p>
Assignment as an expression is a historical choice.
</p>

<p>
It's doing us no favours today.
</p>

<p>
Assignment should be a statement.
</p>

<aside class="notes">
<p>
This is my opinion; I don't know whether this is a particularly controversial
thing to say. Based on the practices I see, I don't think so.
</p>

<p>
When I was at university, my friends and I learned C. It was great. It made us
feel very powerful. We were used to doing all kinds of questionable things in C.
And then we learned Modula-3 (a language in the Pascal family). And then we
frequently ran up against a particular error.
</p>

</aside>

</section>
<section id="slide-org21d3ac9">
<h3 id="org21d3ac9">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"Expression is not a statement."
</p>
<div></div><div class='author'>
<p>
&#x2013; Modula-3 compiler, 1993
</p>
</div>
</blockquote>
<br clear="all"/>

<p>
And quite right, too.
</p>

<aside class="notes">
<p>
In Modula-3, unlike C++, there is no expression-statement. Expressions are
expressions and statements are statements, and never the twain shall meet.
</p>

<p>
Modula-3 is not an expression-oriented language. But this didn't start with C:
so-called expression-oriented languages were already around for a while, notably
ALGOL-68 (1968) and LISP (1958).
</p>

<p>
So we need to go back a bit.
</p>

</aside>

</section>
<section id="slide-orga82a5f7">
<h3 id="orga82a5f7">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">/* </span><span style="color: #006400;">The following function will print a non-negative number, n, to</span>
<span style="color: #006400;">   the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that</span>
<span style="color: #006400;">   in the ASCII character set, the digits 0 to 9 have sequential</span>
<span style="color: #006400;">   code values.  </span><span style="color: #006400;">*/</span>
<span style="color: #0000ff;">printn</span><span style="color: #707183;">(</span>n, b<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">extrn</span> <span style="color: #a0522d;">putchar</span>;
    <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">a</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>a = n / b<span style="color: #7388d6;">)</span>
        printn<span style="color: #7388d6;">(</span>a, b<span style="color: #7388d6;">)</span>; <span style="color: #006400;">/* </span><span style="color: #006400;">recursive </span><span style="color: #006400;">*/</span>
    putchar<span style="color: #7388d6;">(</span>n % b + <span style="color: #b22222;">'0'</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
I had to tell my syntax highlighter that this was C. Does anyone know what
language this is?
</p>

<p>
From the Users' Reference to B by Ken Thompson. (B: 1969)
</p>

<p>
B was descended from Martin Richards' BCPL (1967), which had an assignment
command, not an assignment expression.
</p>

</aside>

</section>
<section id="slide-org60ce067">
<h3 id="org60ce067">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<p>
We've learned to deal with this. But we don't really like it.
</p>
<ul>
<li class="fragment appear">yoda conditions</li>
<li class="fragment appear">compiler warnings</li>
<li class="fragment appear">P0963: discouraged</li>

</ul>

<aside class="notes">
<p>
This is why I don't think it's controversial to say that assignment shouldn't be
an expression.
</p>

<p>
This is a holdover from history that we increasingly don't like, and we're
increasingly finding ways to avoid. P0963: structured binding declaration as a
condition
</p>

</aside>

</section>
<section id="slide-orgc572970">
<h3 id="orgc572970">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">/* </span><span style="color: #006400;">The following function will print a non-negative number, n, to</span>
<span style="color: #006400;">   the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that</span>
<span style="color: #006400;">   in the ASCII character set, the digits 0 to 9 have sequential</span>
<span style="color: #006400;">   code values.  </span><span style="color: #006400;">*/</span>
<span style="color: #0000ff;">printn</span><span style="color: #707183;">(</span>n, b<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">extrn</span> <span style="color: #a0522d;">putchar</span>;
    <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">a</span>;

    <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>a = n / b<span style="color: #7388d6;">)</span>    <span style="color: #006400;">/* </span><span style="color: #006400;">assignment, not test for equality </span><span style="color: #006400;">*/</span>
        printn<span style="color: #7388d6;">(</span>a, b<span style="color: #7388d6;">)</span>; <span style="color: #006400;">/* </span><span style="color: #006400;">recursive </span><span style="color: #006400;">*/</span>
    putchar<span style="color: #7388d6;">(</span>n % b + <span style="color: #b22222;">'0'</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The same snippet of B.
</p>

<p>
Note the comment I left in this time. We're used to this today. But it's worth
asking why it is that way.
</p>

</aside>

</section>
<section id="slide-orga723bd9">
<h3 id="orga723bd9">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"A notorious example for a bad idea was the choice of the equal sign to denote
assignment."
</p>
<div></div><div class='author'>
<p>
&#x2013; Niklaus Wirth
</p>
</div>
</blockquote>

<aside class="notes">
<p>
"Because it overthrows a century old tradition to let “=” denote a comparison
for equality, a predicate which is either true or false."
</p>

<p>
"the operands are on unequal footing &#x2026; x = y does not mean the same thing as y = x."
</p>

<p>
From this I conclude that Niklaus Wirth is not really a fan of operator
overloading. We'll come back to this idea later.
</p>

</aside>

</section>
<section id="slide-orga8b5b1f">
<h3 id="orga8b5b1f">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Superplan (1951) introduced <code>=</code> for assignment</li>
<li class="fragment appear">FORTRAN (1957) used <code>=</code> (because <code>.GT.</code> <code>.LT.</code> <code>.EQ.</code> etc)</li>
<li class="fragment appear">ALGOL-58 introduced <code>:=</code> (assignment) distinct from <code>=</code> (equality)
<ul>
<li>Subsequently many languages went this way</li>

</ul></li>
<li class="fragment appear">BCPL (1967) used <code>:=</code></li>
<li class="fragment appear">B (1969) simplified a lot of BCPL syntax, went with <code>=</code>
<ul>
<li>Followed by C (1972) and many other languages</li>

</ul></li>

</ul>

<aside class="notes">
<p>
The 50s and 60s was an incredible time for programming language innovation.
Superplan introduced the for loop!
</p>

<p>
FORTRAN had to use a very restricted character set. There were no greater than
or less than symbols, hence the idiosyncratic relational operators and the
freeing up of equals for assignment.
</p>

<p>
B is responsible for almost all the operators we have in C++ today.
</p>

</aside>

</section>
<section id="slide-orgd1ee237">
<h3 id="orgd1ee237">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"Since assignment is about twice as frequent as equality testing
in typical programs, it’s appropriate that the operator be half as long."
</p>
<div></div><div class='author'>
<p>
&#x2013; Ken Thompson
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Ken Thompson wanted to fit BCPL on the PDP-7. BCPL's compiler at the time was
16k. PDP-7 had 4k of memory. So Ken cut down the number of characters in source
wherever he could.
</p>

</aside>

</section>
<section id="slide-org8fbc698">
<h3 id="org8fbc698">Declaration vs (Re-)Assignment</h3>
<div class='vertspace2'></div>
<p>
In moving from BCPL to B, the distinction between
</p>

<p>
declaration and reassignment was blurred.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = <span style="color: #008b8b;">42</span>; <span style="color: #006400;">// </span><span style="color: #006400;">declaration/initialization</span>

a = <span style="color: #008b8b;">1729</span>; <span style="color: #006400;">// </span><span style="color: #006400;">assignment</span>
</pre>
</div>

<blockquote nil>
<p>
"It cannot be overemphasized that <b>assignment and initialization are different
operations</b>."
</p>
<div></div><div class='author'>
<p>
&#x2013; Bjarne Stroustrup, <i>The C++ Programming Language</i>
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Early languages (50s and 60s) often distinguished const-declaration from
variable-decl-and-assignment. ALGOL-68 for example. Pascal-type languages still
do.
</p>

<p>
Consider <code>int</code> here replaced with <code>let</code>, and you have a mathematical declaration
or variable introduction. A mathematical assignment is nonsensical.
</p>

<p>
This distinction was clear in BCPL, which uses = for declaration and := for
reassignment. But the cutting-down-for-memory of B introduced ambiguity.
</p>

</aside>

</section>
<section id="slide-org93869c7">
<h3 id="org93869c7">&lt;End of Historical Diversion&gt;</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Declaring things is &#x2013; has always been &#x2013; fine.</li>
<li class="fragment appear">Declaration and assignment are different things that look the same.</li>
<li class="fragment appear">Assignment as an expression statement is best avoided.
<ul>
<li>Chained assignments are a syntactic laziness.</li>

</ul></li>

</ul>

<aside class="notes">
<p>
What does a look at history tell us about programming style, especially
declarative style?
</p>

<p>
Assignment as an expression is a lazy convenience that doesn't do us any
favours. Expression statements have always been a trap for the unwary.
</p>

<p>
That's why we have warnings for things like this. And that's why we have things
like if-initializers and nodiscard attributes.
</p>

<p>
I can think of no reason to use chained assignments. I grepped my code base and
found zero occurrences.
</p>

</aside>

</section>
<section id="slide-org416c053">
<h3 id="org416c053">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-broken_heart"></i></td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Assignment used as an expression per se is looking on shaky ground.
We don't like it.
</p>

<ul>
<li>-wunused-value ("statement has no effect")</li>
<li>yoda conditions</li>

</ul>

<p>
Best avoided. Prefer declarations, some of us use AAA, many of us use const
where we can.
</p>

<p>
We guard against expression statements in general: <code>nodiscard</code> attribute in
C++17.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org85e5745">
<h2 id="org85e5745">A Quick Declarative Study</h2>
<aside class="notes">
<p>
Let's look at a fairly common code snippet and examine some different ways to
write it in a modern, potentially declarative style.
</p>

</aside>

</section>
<section id="slide-org57ab574">
<h3 id="org57ab574">Example</h3>
<div class='vertspace2'></div>
<p>
Given:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">weak_ptr</span><span style="color: #707183;">&lt;</span>Foo<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">wp</span>;
</pre>
</div>
<p>
How to write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span>;
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>sp<span style="color: #7388d6;">)</span> b = sp-&gt;bar<span style="color: #7388d6;">()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
In a (more) declarative way.
</p>

<aside class="notes">
<p>
Here is an imperative piece of code. What's wrong with it?
</p>

<ul>
<li>declaration/initialization split (b could well be const after init)</li>
<li>mutable state</li>
<li>scope control (note convention)</li>

</ul>

<p>
This code would likely pass code review. It's the best we can do with imperative
style. It's ticking several guideline boxes. But it's still unsatisfying.
</p>

<p>
I'm using <code>shared_ptr</code> here as a standin for some generic access that requires
this kind of pattern: the pattern is not just for <code>shared_ptr</code>.
</p>

</aside>

</section>
<section id="slide-org84c163d">
<h3 id="org84c163d">C++17 if-initializer?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span>;
<span style="color: #a020f0;">if</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock<span style="color: #7388d6;">()</span>; sp<span style="color: #707183;">)</span>
  b = sp-&gt;bar<span style="color: #707183;">()</span>;
</pre>
</div>
<p>
This still has the declaration/initialization split. Still has mutable state.
</p>

<aside class="notes">
<p>
Note: this is sort of a workaround for the assignment being an expression.
</p>

<p>
I think it likely that this will become a style that replaces the simple
assignment-as-an-expression.
</p>

</aside>

</section>
<section id="slide-orgce26f09">
<h3 id="orgce26f09">Conditional operator?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = wp.lock<span style="color: #707183;">()</span> ? wp.lock<span style="color: #707183;">()</span>-&gt;bar<span style="color: #707183;">()</span> : Bar<span style="color: #707183;">{}</span>;
</pre>
</div>
<p>
Hm&#x2026;
</p>

<aside class="notes">
<p>
This is also often known as the ternary operator; the standard calls it the
conditional operator.
</p>

<p>
I think this works? Temporary lives until semicolon? But double lock.
</p>

</aside>

</section>
<section id="slide-org13f6141">
<h3 id="org13f6141">C++?? conditional-operator-initializer?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">this isn't real syntax...</span>
<span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = <span style="color: #707183;">[</span><span style="color: #a020f0;">auto</span> sp = wp.lock<span style="color: #7388d6;">()</span>; sp<span style="color: #707183;">]</span> ? sp-&gt;bar<span style="color: #707183;">()</span> : Bar<span style="color: #707183;">{}</span>;
</pre>
</div>
<p>
Might be nice&#x2026; but not today.
</p>

<aside class="notes">
<p>
Expressions and statements aren't equivalent, even when they "are".
</p>

<p>
Unlike <code>if</code>, syntax doesn't allow us to put a declaration in the condition.
</p>

</aside>

</section>
<section id="slide-orge0b877f">
<h3 id="orge0b877f">GCC Extension?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> =
<span style="color: #707183;">(</span><span style="color: #7388d6;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">sp</span> = wp.lock<span style="color: #909183;">()</span>;
  sp ? sp-&gt;bar<span style="color: #909183;">()</span> : Bar<span style="color: #909183;">{}</span>;
<span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
Not ISO C++.
</p>

<aside class="notes">
<p>
GCC has an extension called a statement expression.
</p>

<p>
This is similar to how a compound statement might be handled in a functional
language, where the value of the statement is the value of the last statement in
the body.
</p>

<p>
Of course this leads us to what many of you were already thinking&#x2026;
</p>

</aside>

</section>
<section id="slide-org5adad8d">
<h3 id="org5adad8d">I+LE?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = <span style="color: #707183;">[</span>&amp;<span style="color: #707183;">]</span> <span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock<span style="color: #909183;">()</span>; sp<span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> sp-&gt;bar<span style="color: #7388d6;">()</span>;
  <span style="color: #a020f0;">return</span> Bar<span style="color: #7388d6;">{}</span>;
<span style="color: #707183;">}()</span>;
</pre>
</div>
<p>
Immediately-invoked, inline, initializing, &#x2026;
</p>

<aside class="notes">
<p>
Very much in vogue at the moment.
</p>

<p>
This might be OK? Avoids declaration/initialization split anyway. Depends on
your codebase style.
</p>

</aside>

</section>
<section id="slide-org695526f">
<h3 id="org695526f">Optional-like?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = get_bar_or<span style="color: #707183;">(</span>wp.lock<span style="color: #7388d6;">()</span>, Bar<span style="color: #7388d6;">{}</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
Not really generic enough.
</p>

<aside class="notes">
<p>
This is a good interface for optional, but (at least until we have reflection)
we can't parameterize over the name of the member variable.
</p>

</aside>

</section>
<section id="slide-org933d7b6">
<h3 id="org933d7b6">Functorial/Monadic Interface?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">shared_ptr</span><span style="color: #707183;">&lt;</span>Bar<span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">b</span> = fmap<span style="color: #707183;">(</span>wp.lock<span style="color: #7388d6;">()</span>,
                         <span style="color: #7388d6;">[]</span> <span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">foo</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> foo.bar<span style="color: #909183;">()</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">[</span><span style="color: #7388d6;">[</span><span style="color: #008b8b;">nodiscard</span><span style="color: #7388d6;">]</span><span style="color: #707183;">]</span> <span style="color: #a020f0;">auto</span> fmap<span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">shared_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>&amp; <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span>
    -&gt; <span style="color: #228b22;">shared_ptr</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">invoke_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">F</span>, <span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This might be OK? Again depends on your codebase style.
</p>

<p>
Note the nodiscard attribute: another piece of imperative safety gear that helps
us avoid the pitfalls of statements.
</p>

</aside>

</section>
<section id="slide-orgd2a23a6">
<h3 id="orgd2a23a6">Study Conclusions</h3>
<div class='vertspace2'></div>
<p>
"Total" declarative style is not always achievable in C++.
</p>

<p>
A <i>more</i> declarative style is a reasonable goal.
</p>

<p>
Some features of C++ help us get there.
</p>

<p>
Different domains lean towards different approaches.
</p>

<aside class="notes">
<p>
IILEs help, nodiscard attribute helps
</p>

<p>
Different domains: we probably wouldn't want to use a monadic approach for
<code>shared_ptr</code>. But we might well want to for futures. For errors, the answer
would probably depend on our codebase's existing practice.
</p>

<p>
A key idea is to minimize statements and maximize the use of expressions. This
maximizes the compiler's help.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgfca2a0a">
<h2 id="orgfca2a0a">Existing Declarative Practice</h2>
<div class='vertspace2'></div>
<p>
We are surrounded by guidelines, goals and idioms.
</p>

<p>
Looking through a declarative lens, we can tie it together.
</p>

</section>
<section id="slide-orgc27fa73">
<h3 id="orgc27fa73">Core Guidelines</h3>
<div class='vertspace2'></div>
<p>
<i><code>Con.1</code></i> By default, make objects immutable.
</p>

<p>
<i><code>Con.4</code></i> Use <code>const</code> to define objects with values that do not change after
construction.
</p>

<p>
<i><code>ES.21</code></i> Don't introduce a variable (or constant) before you need to use it.
</p>

<p>
<i><code>ES.22</code></i> Don't declare a variable until you have a value to initialize it with.
</p>

<p>
<i><code>ES.28</code></i> Use lambdas for complex initialization.
</p>

<aside class="notes">
<p>
Of course we've been doing ES 21 &amp; 22 forever; the ability to declare variables
at the point of use is one of the things that separates C++ from C.
</p>

<p>
Corollary to <i>Con.4</i>: we probably have lots of objects that can be <code>const</code>.
</p>

<p>
Just watch a few episodes of C++Weekly&#x2026;
</p>

</aside>

</section>
<section id="slide-orge35b208">
<h3 id="orge35b208">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
We try to avoid assignment after initialization: assignment as an expression.
</p>

<p>
This allows us to take advantage of immutability for correctness and
performance, and optimizations like RVO.
</p>

<p>
This also reduces the need for scoping auxiliary variables and therefore reduces
the need for compound statements.
</p>

</aside>

</section>
<section id="slide-org8cb5b36">
<h3 id="org8cb5b36">Functions in General</h3>
<div class='vertspace2'></div>
<p>
Which is better?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">do A</span>
<span style="color: #0000ff;">...</span>
<span style="color: #006400;">// </span><span style="color: #006400;">do B</span>
<span style="color: #0000ff;">...</span>
<span style="color: #006400;">// </span><span style="color: #006400;">do C</span>
<span style="color: #0000ff;">...</span>
</pre>
</div>
<p>
or
</p>
<div class="org-src-container">

<pre  class="src src-c++">do_A<span style="color: #707183;">()</span>;
do_B<span style="color: #707183;">()</span>;
do_C<span style="color: #707183;">()</span>;
</pre>
</div>
<p>
?
</p>

<aside class="notes">
<p>
From Tony's talk: the number of times you need to see the same code to make a function?
</p>

<p>
Just 1. So we like functions. Why?
</p>

</aside>

</section>
<section id="slide-org1fce83b">
<h3 id="org1fce83b">The "Normal" Reasons</h3>
<div class='vertspace2'></div>
<ul>
<li>shorter is more expressive, understandable</li>
<li>encapsulation of variable scopes, lifetimes, concerns</li>
<li>functions give things names</li>

</ul>

<aside class="notes">
<p>
These are the normal reasons given for liking functions.
</p>

<p>
And they're great. I like functions for all these reasons.
</p>

</aside>

</section>
<section id="slide-orgaee1d43">
<h3 id="orgaee1d43">Another Reason</h3>
<div class='vertspace2'></div>
<p>
Functions turn statements into expressions.
</p>

<ul>
<li><code>return</code> is the socially acceptable <code>goto</code></li>
<li>way better than <code>break</code></li>
<li>and if that wasn't enough, RVO</li>

</ul>

<aside class="notes">
<p>
I am not a fan of "one exit path per function". I don't think this is a
particularly controversial point of view. In C++ it's an antipattern. When you
have RAII, you don't need this!
</p>

<p>
Early-outs make for shallow, simple conditions. <code>return</code> can very simply cut out
of find-style algorithms.
</p>

<p>
According to one of the top answers on stack overflow, the notion of single-exit
was introduced with Structured Programming as a guard against alternate returns,
which were not returns <i>from</i> multiple places but returns <i>to</i> multiple places.
e.g. in FORTRAN when a function had an error it would do an alternate return to
a place where the error was handled.
</p>

</aside>

</section>
<section id="slide-org8df5353">
<h3 id="org8df5353">&lt;algorithm&gt;</h3>
<div class='vertspace2'></div>
<p>
"No Raw Loops"
</p>

<p>
What does that mean?
</p>
<ul>
<li>encapsulate iteration statements</li>
<li>encapsulate remaining assignments</li>
<li>encapsulate <code>break</code> and <code>continue</code></li>

</ul>

<aside class="notes">
<p>
Algorithms are essentially declarative: they are functions. They are expressive.
They have names. They declare what's going on.
</p>

<p>
"No raw loops" as a goal is a subset of "strive for declarative code".
</p>

<p>
It exhorts us to take these statement types and push them down out of the
business logic.
</p>

</aside>

</section>
<section id="slide-orgc0d9b59">
<h3 id="orgc0d9b59"><code>#include "my_algorithms.h"</code></h3>
<div class='vertspace2'></div>
<ul>
<li><code>min_unused</code></li>
<li><code>is_prefix_of</code></li>
<li><code>join</code></li>
<li><code>transform_if</code></li>
<li><code>set_differences</code> (aka before and after)</li>
<li><code>push_back_unique</code></li>

</ul>

<aside class="notes">
<p>
Here is a selection of algorithms in my toolkit.
</p>

<p>
None of these algorithms is groundbreaking. Some of them are little more than
rebrandings of one-liners. None of them is more than a handful of lines.
</p>

<p>
What they <i>do</i> is avoid statements in logic. They simplify control flow. Notice
also that all well-written algorithms deal with the edge cases: primarily empty
ranges. You don't have to put conditions or loops in your logic!
</p>

</aside>

</section>
<section id="slide-org99be66c">
<h3 id="org99be66c">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
So, "no raw loops" is leading us to avoid iteration and jump statements.
</p>

<p>
I+LEs and initialization guidelines lead us to avoid assignments.
</p>

<p>
Let's look now at how to avoid conditions. Hint: we're already doing it.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3a8256d">
<h2 id="org3a8256d">Declarative Domains and Patterns</h2>
<div class="outline-text-2" id="text-org3a8256d">
</div>
</section>
<section id="slide-org26a8aba">
<h3 id="org26a8aba">Testing</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a0522d;">TEST_CASE</span><span style="color: #707183;">(</span> <span style="color: #b22222;">"Factorials are computed"</span>, <span style="color: #b22222;">"[factorial]"</span> <span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    REQUIRE<span style="color: #7388d6;">(</span> Factorial<span style="color: #909183;">(</span><span style="color: #008b8b;">1</span><span style="color: #909183;">)</span> == <span style="color: #008b8b;">1</span> <span style="color: #7388d6;">)</span>;
    REQUIRE<span style="color: #7388d6;">(</span> Factorial<span style="color: #909183;">(</span><span style="color: #008b8b;">2</span><span style="color: #909183;">)</span> == <span style="color: #008b8b;">2</span> <span style="color: #7388d6;">)</span>;
    REQUIRE<span style="color: #7388d6;">(</span> Factorial<span style="color: #909183;">(</span><span style="color: #008b8b;">3</span><span style="color: #909183;">)</span> == <span style="color: #008b8b;">6</span> <span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Conditions are encapsulated; nothing is dependent.
</p>
<ul>
<li class="fragment appear">idempotent</li>
<li class="fragment appear">minimal temporal dependency between statements</li>
<li class="fragment appear">leverage constructors/RAII</li>
<li class="fragment appear">popularity of sections over fixture management</li>

</ul>

<aside class="notes">
<p>
This is from Catch.
</p>

<p>
Testing use macros to hide constructor/RAII syntax. It also uses global state.
Declarative style isn't incompatible with global state; sometimes you have to do
what you have to do.
</p>

<p>
C++ is a multiparadigm language; declarative style isn't "pure FP or nothing".
</p>

</aside>

</section>
<section id="slide-org9b75f6f">
<h3 id="org9b75f6f">Logging : Imperative turned Declarative</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c">fprintf<span style="color: #707183;">(</span>g_debugLogFilep, <span style="color: #b22222;">"R Tape loading error, %d:%d"</span>, line, stmt<span style="color: #707183;">)</span>;
</pre>
</div>
<p>
vs
</p>
<div class="org-src-container">

<pre  class="src src-c++">LOG<span style="color: #707183;">(</span><span style="color: #b22222;">"R Tape loading error, "</span> &lt;&lt; line &lt;&lt; <span style="color: #b22222;">':'</span> &lt;&lt; stmt<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Logging is very often declarative. Nothing much new here, but let's explore a
bit because it's a domain that benefits greatly from declarative practice.
</p>

<p>
We're using overloaded operators. We're using RAII. We've got a declarative,
concatenative style. What has been gained here?
</p>

<p>
Composability: through operator overloading, we have the ability to extend the
expression, because expressions are composable.
</p>

<p>
Extensibility: we can provide the operator for our own types.
</p>

<p>
Type checking: with fprintf, the format string and the arguments have to match
or bad things will happen. Usually the worst we can expect with LOG is that we
get unexpected conversions of the arguments.
</p>

</aside>

</section>
<section id="slide-org8d18ace">
<h3 id="org8d18ace">Where Did the Global Go?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">// </span><span style="color: #006400;">g_debugLogFilep is a global variable</span>
fprintf<span style="color: #707183;">(</span>g_debugLogFilep, <span style="color: #b22222;">"R Tape loading error, %d:%d"</span>, line, stmt<span style="color: #707183;">)</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">somewhere, a "global" variable lurks? where does the log go to?</span>
LOG<span style="color: #707183;">(</span><span style="color: #b22222;">"R Tape loading error, "</span> &lt;&lt; line &lt;&lt; <span style="color: #b22222;">':'</span> &lt;&lt; stmt<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Logging framework? What has replaced the global variable? Functions and/or
declarations in the global namespace.
</p>

<p>
A sink is where logs go to. In the C case, <code>g_debugLogFilep</code>. In the C++ case, a
global variable that is hidden inside the RAII object constructed with LOG.
</p>

<p>
The benefits of declarative style outweigh the drawbacks of having a few global
variables for domains like this.
</p>

<p>
But let's look at the log sink interface, because that's another good example of
how current practice is limiting statements.
</p>

</aside>

</section>
<section id="slide-orgdbfb707">
<h3 id="orgdbfb707">C-Style Log Sink</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c">fprintf<span style="color: #707183;">(</span>g_debugLogFilep, <span style="color: #b22222;">"R Tape loading error, %d:%d"</span>, line, stmt<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
What would we do if we wanted to change where the log went?
</p>

<aside class="notes">
<p>
In the 70s, we would write to stdout and change the destination with the shell
using pipes or tee. This is still perfectly fine if we're writing small console
apps, but if we're writing larger apps, we want more control. The ability to
wrangle logging options at runtime.
</p>

<p>
In the C style we'd probably encapsulate in our own function - likely one of the
v-prefixed printf functions. In OO-style?
</p>

</aside>

</section>
<section id="slide-orge09a721">
<h3 id="orge09a721">Log Sinks: OO turned Declarative</h3>
<div class='vertspace2'></div>
<p>
A study in compositional design.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Sink</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">bool</span> Push<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp; <span style="color: #a0522d;">e</span><span style="color: #7388d6;">)</span>;
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
A log sink takes the place of the global file pointer. It's an RAII object - on
destruction, the logger object dispatches the log entry to the sink. And it can
add entry information: a timestamp, file, line, etc (this is typically why it's
a macro).
</p>

<p>
So let's talk about log sinks, which is an example of applying declarative style
to a traditionally object-oriented approach. The key is composition.
</p>

<p>
A Sink has one important method: to push an entry. Notice it returns bool
indicating whether or not the entry was actually accepted.
</p>

<p>
With just this basic interface, we have quite a range of choices in sinks we can
make.
</p>

</aside>

</section>
<section id="slide-orgd833c50">
<h3 id="orgd833c50">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">FileSink</span> : <span style="color: #228b22;">Sink</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
  FileSink<span style="color: #7388d6;">(</span><span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">pathname</span><span style="color: #7388d6;">)</span>;
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">DebugSink</span> : <span style="color: #228b22;">Sink</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
At a basic level, we can make different sinks that go to different places. One
to a log file, one to the debug window, maybe one to a listening log aggregator
service over the network.
</p>

</aside>

</section>
<section id="slide-org21805fb">
<h3 id="org21805fb">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">FilterSink</span> : <span style="color: #228b22;">Sink</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Pred</span><span style="color: #7388d6;">&gt;</span>
  FilterSink<span style="color: #7388d6;">(</span><span style="color: #228b22;">Pred</span> <span style="color: #a0522d;">p</span><span style="color: #7388d6;">)</span>;
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">using</span> Predicate = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">bool</span><span style="color: #909183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp;<span style="color: #909183;">)</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">Predicate</span> <span style="color: #a0522d;">pred</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We can also make sinks that inspect the log entry and only accept certain
entries. So we can make a sink that filters entries passed to it.
</p>

</aside>

</section>
<section id="slide-org094a39d">
<h3 id="org094a39d">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Exercise for the reader: ExecutionPolicy Concept</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">ExecutionPolicy</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">ExecSink</span> : <span style="color: #228b22;">Sink</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We can make a sink that wraps another sink and implements an execution policy,
so we can implement threaded logging or deferred flushing.
</p>

</aside>

</section>
<section id="slide-org797ffc7">
<h3 id="org797ffc7">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">MultiSink</span> : <span style="color: #228b22;">Sink</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
  <span style="color: #228b22;">vector</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">unique_ptr</span><span style="color: #909183;">&lt;</span>Sink<span style="color: #909183;">&gt;</span><span style="color: #7388d6;">&gt;</span> sinks;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We can make a sink that wraps multiple other sinks and passes entries through to
them. And we can parameterize that on whether it will stop at the first
accepting sink, or fan out to all.
</p>

</aside>

</section>
<section id="slide-org30b8005">
<h3 id="org30b8005">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">NullSink</span> : <span style="color: #228b22;">Sink</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">bool</span> Push<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp;<span style="color: #7388d6;">)</span> <span style="color: #a020f0;">override</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>; <span style="color: #7388d6;">}</span>
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We can make a null sink that just returns true from Push().
</p>

<p>
What is the goal with all these variations?
</p>

<p>
Object orientation: tell, don't ask. We're encapsulating conditions using
polymorphism.
</p>

</aside>

</section>
<section id="slide-org517ba3f">
<h3 id="org517ba3f">Declarative Sink Construction</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fileSink</span> = <span style="color: #707183;">[</span>&amp;<span style="color: #707183;">]</span> <span style="color: #707183;">()</span> -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #707183;">&lt;</span>Sink<span style="color: #707183;">&gt;</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>logToFile<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::make_unique<span style="color: #909183;">&lt;</span>FileSink<span style="color: #909183;">&gt;(</span>generate_filename<span style="color: #709870;">()</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::make_unique<span style="color: #909183;">&lt;</span>NullSink<span style="color: #909183;">&gt;()</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}()</span>;
</pre>
</div>
<p>
Conditions are encapsulated at the point of construction.
</p>

<p>
The point of use is condition-free and declarative.
</p>

<aside class="notes">
<p>
Good OO style tells us this. We use things like dependency injection and the
null object pattern - they're all about encapsulating conditions inside the
class, pushing the choice up the callstack and removing the condition from the
code that uses the object.
</p>

<p>
And of course here's an I+LE. Great for inlining short factory functions.
Unfortunately the conditional operator can't easily be used here because of the
<code>common_type</code> requirement.
</p>

<p>
I'm using a conventional inheritance structure here to show that declarative
style is not just about value types. Of course you could use an alternative form
of polymorphism like type erasure. It wouldn't change the point here.
</p>

</aside>

</section>
<section id="slide-orgdeabb37">
<h3 id="orgdeabb37">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">paradigm shift</td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Compositional patterns like this are the object-oriented way to avoid selection
statements.
</p>

<p>
If we want to turn off logging, we do that at the point of construction. We
don't incur the mental cost of conditions at the point of use.
</p>

<p>
"Killed by paradigm shift" sounds like a way to die in Nethack.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd98df3a">
<h2 id="orgd98df3a">Design Patterns</h2>
<div class="outline-text-2" id="text-orgd98df3a">
</div>
</section>
<section id="slide-orgda87aa7">
<h3 id="orgda87aa7">OO Patterns</h3>
<div class='vertspace2'></div>
<p>
Several patterns lean towards declarative style.
</p>

<p>
Many patterns are about replacing conditions with polymorphism.
</p>

<ul>
<li>Null object</li>
<li>Command</li>
<li>Composite</li>

</ul>

<aside class="notes">
<p>
These patterns have long been my favourites, but I didn't really understand why
until I started thinking about how they encourage declarative style.
</p>

<p>
The Null object pattern eliminates conditions, allowing you to write total functions.
</p>

<p>
Command reifies computation and turns behaviour into something that has a type,
that the compiler can reason about.
</p>

<p>
Composite eliminates conditions by allowing us to treat different elements of a
hierarchy the same.
</p>

<p>
These days there is one construction pattern that comes up a lot in declarative
style.
</p>

</aside>

</section>
<section id="slide-org04094ae">
<h3 id="org04094ae">The "Builder Pattern"</h3>
<div class='vertspace2'></div>
<p>
AKA "Fluent Style" (not the original GoF pattern)
</p>

<div class="org-src-container">

<pre  class="src src-c++">FluentGlutApp<span style="color: #707183;">(</span>argc, argv<span style="color: #707183;">)</span>
  .withDoubleBuffer<span style="color: #707183;">()</span>.withRGBA<span style="color: #707183;">()</span>.withAlpha<span style="color: #707183;">()</span>.withDepth<span style="color: #707183;">()</span>
  .at<span style="color: #707183;">(</span><span style="color: #008b8b;">200</span>, <span style="color: #008b8b;">200</span><span style="color: #707183;">)</span>.across<span style="color: #707183;">(</span><span style="color: #008b8b;">500</span>, <span style="color: #008b8b;">500</span><span style="color: #707183;">)</span>
  .named<span style="color: #707183;">(</span><span style="color: #b22222;">"My OpenGL/GLUT App"</span><span style="color: #707183;">)</span>
  .create<span style="color: #707183;">()</span>;
</pre>
</div>

<blockquote nil>
<p>
"In which the author turns what should be 5 lines of glut calls at the start of
<code>main</code> into 100 lines of buggy OOP."
</p>
<div></div><div class='author'>
<p>
&#x2013; Nicolas Guillemot (via Twitter)
</p>
</div>
</blockquote>

<aside class="notes">
<p>
The wikipedia example for C++ is not compelling. This is not better than the
N lines of single-use code it replaces.
</p>

<p>
Buggy? I'm not sure. But all other things being equal, fewer lines of code are
likely to be more correct. (This isn't fewer lines of code.)
</p>

<p>
Use fluent style where it makes sense: not for single-use code. For code that
will be used a lot. For code where the verbs are few and clear. And for code
where you can make the types work for you.
</p>

<p>
I think I have better examples.
</p>

</aside>

</section>
<section id="slide-org73082df">
<h3 id="org73082df">Builder Pattern: A Better Example</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Schedule&amp; Schedule::then(interval_t);</span>

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">s</span> = Schedule<span style="color: #707183;">(</span><span style="color: #008b8b;">interval</span>::fixed<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1s</span><span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>
  .then<span style="color: #707183;">(</span><span style="color: #008b8b;">repeat</span>::n_times<span style="color: #7388d6;">{</span><span style="color: #008b8b;">5</span>, <span style="color: #008b8b;">interval</span>::random_exponential<span style="color: #909183;">{</span><span style="color: #008b8b;">2s</span>, <span style="color: #008b8b;">2.0</span><span style="color: #909183;">}</span><span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>
  .then<span style="color: #707183;">(</span><span style="color: #008b8b;">repeat</span>::forever<span style="color: #7388d6;">{</span><span style="color: #008b8b;">interval</span>::fixed<span style="color: #909183;">{</span><span style="color: #008b8b;">30s</span><span style="color: #909183;">}</span><span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;typename Timer, typename Task&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">void Schedule::run(Timer, Task);</span>
s.run<span style="color: #707183;">(</span>timer, task<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Building a schedule is something that happens all over the code. It's not
single-use. We've got a single verb: then. We've got types helping us out.
</p>

<p>
Fluent style encourages rvalue usage - useful when we can make it limited in
verbosity. Useful when we won't really ever need the lvalues - no reason to make
an interval other than to immediately put it in a schedule.
</p>

<p>
Readability is good. Schedules are correct by construction.
</p>

</aside>

</section>
<section id="slide-org10afdeb">
<h3 id="org10afdeb">Builder Pattern: Help from C++17</h3>
<div class='vertspace2'></div>
<p>
P0145: Refining Expression Evaluation Order for Idiomatic C++
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span> = <span style="color: #b22222;">"but I have heard it works even if you don't believe in it"</span>;
  s.replace<span style="color: #7388d6;">(</span><span style="color: #008b8b;">0</span>, <span style="color: #008b8b;">4</span>, <span style="color: #b22222;">""</span><span style="color: #7388d6;">)</span>
   .replace<span style="color: #7388d6;">(</span>s.find<span style="color: #909183;">(</span><span style="color: #b22222;">"even"</span><span style="color: #909183;">)</span>, <span style="color: #008b8b;">4</span>, <span style="color: #b22222;">"only"</span><span style="color: #7388d6;">)</span>
   .replace<span style="color: #7388d6;">(</span>s.find<span style="color: #909183;">(</span><span style="color: #b22222;">" don't"</span><span style="color: #909183;">)</span>, <span style="color: #008b8b;">6</span>, <span style="color: #b22222;">""</span><span style="color: #7388d6;">)</span>;
  assert<span style="color: #7388d6;">(</span>s == <span style="color: #b22222;">"I have heard it works only if you believe in it"</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Of course in C++17 we get extra help for using fluent-style interfaces.
Evaluation order is now specified so that this works.
</p>

</aside>

</section>
<section id="slide-orgf682e38">
<h3 id="orgf682e38">Putting Types to Work</h3>
<div class='vertspace2'></div>
<p>
This "builder pattern" is an ideal place to put strong types to work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Build a request object</span>
<span style="color: #228b22;">request_t</span> <span style="color: #a0522d;">req</span> = make_request<span style="color: #707183;">()</span>
  .set_req_field_1<span style="color: #707183;">(</span><span style="color: #0000ff;">...</span><span style="color: #707183;">)</span>
  .set_req_field_2<span style="color: #707183;">(</span><span style="color: #0000ff;">...</span><span style="color: #707183;">)</span>
  .set_opt_field<span style="color: #707183;">(</span><span style="color: #0000ff;">...</span><span style="color: #707183;">)</span>
  .set_opt_field<span style="color: #707183;">(</span><span style="color: #0000ff;">...</span><span style="color: #707183;">)</span>
  .set_opt_field<span style="color: #707183;">(</span><span style="color: #0000ff;">...</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">Use it</span>
send_request<span style="color: #707183;">(</span>req<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
A typical situation.
</p>

<p>
We could put the required fields in the constructor, but we might not want to
build the request all in one go.
</p>

<p>
What should <code>send_request</code> do with a request that accidentally doesn't have the
required fields? Today it most often will assert, or simply send the request and
get a protocol error.
</p>

<p>
What we want is for it to fail to compile.
</p>

<p>
We want to leverage a key ability of expressions over statements: they compose
on the type axis.
</p>

</aside>

</section>
<section id="slide-orgad30e70">
<h3 id="orgad30e70">Putting Types to Work</h3>
<div class='vertspace2'></div>
<p>
The "normal" construct for this behaviour.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_req_field_1</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    f1 = f;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_req_field_2</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_opt_field</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span>;

  <span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f1</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">etc ...</span>
<span style="color: #707183;">}</span>;

<span style="color: #228b22;">request_t</span> <span style="color: #0000ff;">make_request</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> <span style="color: #0000ff;">...</span> <span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
What we want here is to encode the fact that the required fields have been set
(or not) in the type of the request object.
</p>

<p>
Values flow through the computation at runtime; types flow through the
computation at compile-time.
</p>

<p>
We want setting required fields to return a different type. Setting optional
fields should return the same type.
</p>

<p>
We also want setting fields to be idempotent in the type.
</p>

</aside>

</section>
<section id="slide-orgdb99437">
<h3 id="orgdb99437">Behaviour in the Type</h3>
<div class='vertspace2'></div>
<p>
One way: use a bitfield.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">OPT_FIELDS</span> = <span style="color: #008b8b;">1</span> &lt;&lt; <span style="color: #008b8b;">0</span>;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">REQ_FIELD1</span> = <span style="color: #008b8b;">1</span> &lt;&lt; <span style="color: #008b8b;">1</span>;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">REQ_FIELD2</span> = <span style="color: #008b8b;">1</span> &lt;&lt; <span style="color: #008b8b;">2</span>;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">ALL_FIELDS</span> = OPT_FIELDS | REQ_FIELD1 | REQ_FIELD2;
</pre>
</div>

<aside class="notes">
<p>
We're going to encode which fields have been set in a bitfield.
</p>

</aside>

</section>
<section id="slide-org597b6f8">
<h3 id="org597b6f8">Behaviour in the Type</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f1</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">etc ...</span>
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span> : <span style="color: #228b22;">request_t</span><span style="color: #707183;">&lt;</span>N-<span style="color: #008b8b;">1</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #228b22;">request_t</span><span style="color: #7388d6;">&lt;</span>N &amp; ~REQ_FIELD1<span style="color: #7388d6;">&gt;</span>&amp; <span style="color: #0000ff;">set_req_field1</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">this</span>-&gt;f1 = f;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  <span style="color: #7388d6;">}</span>
  <span style="color: #228b22;">request_t</span><span style="color: #7388d6;">&lt;</span>N &amp; ~REQ_FIELD2<span style="color: #7388d6;">&gt;</span>&amp; <span style="color: #0000ff;">set_req_field2</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_opt_field</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
Data members in the base class.
</p>

<p>
Clearing bits in a bitfield is idempotent. The return type of <code>set_req_field_1</code>
might be the same as the type of the this.
</p>

<p>
Clearing bits reduces the non-type template parameter. And through recursion
everything inherits. Finally we get down to the class with only optional fields
left unset, and we can never go below that.
</p>

</aside>

</section>
<section id="slide-orgef42715">
<h3 id="orgef42715">Behaviour in the Type</h3>
<div class='vertspace2'></div>
<p>
Use <code>=delete</code> to enable the <code>send_request</code> function only for a
correctly-filled-in request.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">request_t</span><span style="color: #707183;">&lt;</span>ALL_FIELDS<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">make_request</span><span style="color: #707183;">()</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_request</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">request_t</span><span style="color: #7388d6;">&lt;</span>N<span style="color: #7388d6;">&gt;</span>&amp; <span style="color: #a0522d;">req</span><span style="color: #707183;">)</span> = <span style="color: #a020f0;">delete</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_request</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">request_t</span><span style="color: #7388d6;">&lt;</span>OPT_FIELDS<span style="color: #7388d6;">&gt;</span>&amp; <span style="color: #a0522d;">req</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
All that's left are the driver functions.
</p>

<p>
<code>make_request</code> returns a request with all the bits set.
</p>

<p>
We have to declare, but delete <code>send_request</code> for the "higher level" types so
that they won't match the "lower level" overload. (Remember "higher level" types
derive from "lower level" types.)
</p>

<p>
This is nice use of types. Any non-setter functions can go in the zero
specialization. The type machinery is fairly lightweight if we only have a
couple of required fields, which is typical. No <code>enable_if</code>, no SFINAE, correct
code results in few type instantiations. Of course everything vanishes at
runtime.
</p>

<p>
No includes! All in the language.
</p>

</aside>

</section>
<section id="slide-org9a60deb">
<h3 id="org9a60deb">Builder Pattern Guidelines</h3>
<div class='vertspace2'></div>
<p>
Fluent style is more suitable when:
</p>

<ul>
<li>you have a single verb (<code>then</code>, <code>set_field</code>)</li>
<li>you'll be building objects a lot</li>
<li>you can make types work for you</li>
<li>rvalues aren't too verbose</li>

</ul>

<aside class="notes">
<p>
Don't use for single use. You'll be writing more code to do the same job.
</p>

<p>
Single verb, or few verbs: you don't want a huge builder interface - this also
mitigates the amount of code. You want the code to be obviously correct.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgfff6534">
<h2 id="orgfff6534">Ranges</h2>
<div class='vertspace2'></div>
<p>
Let's talk about ranges a little.
</p>

<aside class="notes">
<p>
Ranges offer the chance for a new leverage of declarative style.
</p>

</aside>

</section>
<section id="slide-org65a0b11">
<h3 id="org65a0b11">Ranges: Example 0</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++">dates_in_year<span style="color: #707183;">(</span><span style="color: #008b8b;">2015</span><span style="color: #707183;">)</span>    <span style="color: #006400;">// </span><span style="color: #006400;">0. Make a range of dates.</span>
  | by_month<span style="color: #707183;">()</span>         <span style="color: #006400;">// </span><span style="color: #006400;">1. Group the dates by month.</span>
  | layout_months<span style="color: #707183;">()</span>    <span style="color: #006400;">// </span><span style="color: #006400;">2. Format the month into a range of</span>
                       <span style="color: #006400;">//    </span><span style="color: #006400;">strings.</span>
  | chunk<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>           <span style="color: #006400;">// </span><span style="color: #006400;">3. Group the months that belong</span>
                       <span style="color: #006400;">//    </span><span style="color: #006400;">side-by-side.</span>
  | transpose_months<span style="color: #707183;">()</span> <span style="color: #006400;">// </span><span style="color: #006400;">4. Transpose the rows and columns</span>
                       <span style="color: #006400;">//    </span><span style="color: #006400;">of the side-by-side months.</span>
  | <span style="color: #008b8b;">view</span>::join         <span style="color: #006400;">// </span><span style="color: #006400;">5. Ungroup the side-by-side months.</span>
  | join_months<span style="color: #707183;">()</span>      <span style="color: #006400;">// </span><span style="color: #006400;">6. Join the string of the transposed</span>
                       <span style="color: #006400;">//    </span><span style="color: #006400;">months.</span>
</pre>
</div>

<aside class="notes">
<p>
From Eric's 2015 C++Now/CppCon talk "Ranges for the Standard Library".
</p>

<p>
This is one expression. Eric said: Composable. Lots of parts are reusable. It
works with infinite ranges. Can show N months side-by-side (3 chosen).
</p>

<p>
No Loops!!! (with 3 exclamation marks). But he went over that point very
quickly. Perhaps it was a throwaway reference to Sean's work. But he didn't
emphasize why no loops was important. (No statements!)
</p>

<p>
Correct by construction. We don't have to do much to convince ourselves that
it's correct. It's built that way.
</p>

</aside>

</section>
<section id="slide-org27c815f">
<h3 id="org27c815f">Ranges: Example N</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">mt19937</span> <span style="color: #0000ff;">gen</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::random_device<span style="color: #7388d6;">{}()</span><span style="color: #707183;">)</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rsvps</span> = rsvp_json                           <span style="color: #006400;">// </span><span style="color: #006400;">json is a valid range</span>
  | <span style="color: #008b8b;">view</span>::remove_if<span style="color: #707183;">(</span><span style="color: #7388d6;">[](</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">elem</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">return</span> <span style="color: #b22222;">"yes"</span> != elem.at<span style="color: #909183;">(</span><span style="color: #b22222;">"response"</span><span style="color: #909183;">)</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>  <span style="color: #006400;">// </span><span style="color: #006400;">filter out non-"yes" RSVP responses</span>
  | <span style="color: #008b8b;">view</span>::transform<span style="color: #707183;">(</span><span style="color: #7388d6;">[](</span><span style="color: #a020f0;">auto</span>&amp;&amp; <span style="color: #a0522d;">elem</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">return</span> elem<span style="color: #909183;">[</span><span style="color: #b22222;">"member"</span><span style="color: #909183;">][</span><span style="color: #b22222;">"name"</span><span style="color: #909183;">]</span>.dump<span style="color: #909183;">()</span>; <span style="color: #7388d6;">}</span><span style="color: #707183;">)</span> <span style="color: #006400;">// </span><span style="color: #006400;">keep name as string</span>
  | <span style="color: #008b8b;">ranges</span>::to_vector                            <span style="color: #006400;">// </span><span style="color: #006400;">convert lazy range to vector</span>
  | <span style="color: #008b8b;">action</span>::shuffle<span style="color: #707183;">(</span>gen<span style="color: #707183;">)</span>;                        <span style="color: #006400;">// </span><span style="color: #006400;">random shuffle vector elements</span>

</pre>
</div>
<p>
From <a href="https://github.com/CoreCppIL/raffle">https://github.com/CoreCppIL/raffle</a>
</p>

<aside class="notes">
<p>
This from the Core C++ Israel user group. It's the code they use to randomly
pick from meetup.com RSVPs. This is only part of the code but the whole of the
code is designed to fit on one slide.
</p>

<p>
Once again this whole thing is a composition of two declarations and lots of
expressions.
</p>

<p>
Now, you might look at this and think: I can't read that easily&#x2026;
</p>

</aside>

</section>
<section id="slide-org399d832">
<h3 id="org399d832">Ranges: Readability is Familiarity</h3>
<div class='vertspace2'></div>

<p>
What does this do?
</p>

<div class="org-src-container">

<pre  class="src src-apl">+\⍳10
</pre>
</div>

<aside class="notes">
<p>
This is probably not familiar to you.
</p>

<p>
Who knows what language this is?
</p>

<p>
Yes, that's a greek letter.
</p>

</aside>

</section>
<section id="slide-org4f6e63b">
<h3 id="org4f6e63b">Ranges: Readability is Familiarity</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">arr</span><span style="color: #707183;">[]</span> = <span style="color: #707183;">{</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span>,<span style="color: #008b8b;">4</span>,<span style="color: #008b8b;">5</span>,<span style="color: #008b8b;">6</span>,<span style="color: #008b8b;">7</span>,<span style="color: #008b8b;">8</span>,<span style="color: #008b8b;">9</span>,<span style="color: #008b8b;">10</span><span style="color: #707183;">}</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sum</span> = <span style="color: #008b8b;">0</span>;
<span style="color: #a020f0;">for</span> <span style="color: #707183;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = <span style="color: #008b8b;">0</span>; i &lt; <span style="color: #008b8b;">10</span>; ++i<span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  sum += arr<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span>;
  arr<span style="color: #7388d6;">[</span>i<span style="color: #7388d6;">]</span> = sum;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Is this code correct?
</p>

<p>
What is the performance?
</p>

<p>
How sure are you? How long do you need to look at this code to know what it
does?
</p>

<p>
How likely is this code to retain its properties?
</p>

</aside>

</section>
<section id="slide-orgee47984">
<h3 id="orgee47984">Ranges: Readability is Familiarity</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #008b8b;">10</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">input</span>;
<span style="color: #008b8b;">std</span>::iota<span style="color: #707183;">(</span>input.begin<span style="color: #7388d6;">()</span>, input.end<span style="color: #7388d6;">()</span>, <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
<span style="color: #008b8b;">std</span>::partial_sum<span style="color: #707183;">(</span>input.begin<span style="color: #7388d6;">()</span>, input.end<span style="color: #7388d6;">()</span>, input.begin<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Is this code correct? (You may have to look up whether <code>partial_sum</code> allows
"overwriting" of the range - it's not obvious.
</p>

<p>
What is the performance?
</p>

<p>
How sure are you? How long do you need to look at this code to know what it
does?
</p>

<p>
How likely is this code to retain its properties?
</p>

</aside>

</section>
<section id="slide-org6d694e4">
<h3 id="org6d694e4">Ranges: Readability is Familiarity</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-apl">+\⍳10
</pre>
</div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">r</span> = <span style="color: #008b8b;">view</span>::iota<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>
       | <span style="color: #008b8b;">view</span>::take<span style="color: #707183;">(</span><span style="color: #008b8b;">10</span><span style="color: #707183;">)</span>
       | <span style="color: #008b8b;">view</span>::partial_sum<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">plus</span><span style="color: #7388d6;">&lt;&gt;{}</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
We can be pretty sure this is correct.
</p>

<p>
It is likely to remain correct. It's actually still correct if we change the
order of <code>partial_sum</code> and <code>take</code>.
</p>

<p>
You have to put some trust in the implementer of the functions. But "view" is a
good sign that these things don't take up a lot of space and only hold exactly
what they need to advance.
</p>

</aside>

</section>
<section id="slide-org844e175">
<h3 id="org844e175">Readable &amp; Robust</h3>
<div class='vertspace2'></div>
<p>
Code that says WHAT is just as readable as code that says HOW.
</p>

<p>
We are used to seeing code that says HOW. It's more familiar.
</p>

<p>
Code that says WHAT is more likely to remain robust.
</p>

<aside class="notes">
<p>
I would say MORE readable.
</p>

</aside>

</section>
<section id="slide-org339db22">
<h3 id="org339db22">"Wholemeal Programming"</h3>
<div class='vertspace2'></div>
<p>
Declarative style is about processing data pipelines.
</p>

<p>
When you have composable pieces, rearranging and exploring data is quick and
easy.
</p>

<p>
Compare: unix command-line.
</p>
<ul>
<li class="fragment appear">generators (find, <code>iota</code>)</li>
<li class="fragment appear">selections (grep, <code>unique</code>)</li>
<li class="fragment appear">transformations (cut, tr, <code>transform</code>)</li>
<li class="fragment appear">permutations (sort, <code>shuffle</code>)</li>
<li class="fragment appear">reductions/unfolds (wc, xargs, <code>accumulate</code>)</li>

</ul>

<aside class="notes">
<p>
What's the point here? These are very easy to string together, so that they
support exploratory work.
</p>

<p>
Combos of these where convenient, e.g. <code>chunk</code>.
</p>

<p>
In functional circles this is sometimes called "Wholemeal programming" as
distinct from the "piecemeal programming" of imperative loops and conditions.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf0293ac">
<h2 id="orgf0293ac">Operator Overloading</h2>
<div class='vertspace2'></div>
<p>
Good or bad?
</p>

<p class="fragment (appear)">
Answer: good. When principled.
</p>

<aside class="notes">
<p>
Don't know if you've noticed, but we've seen a lot of code that uses operators.
Ranges, tests, logging.
</p>

<p>
Declarative style relies on composition and expressions, so operators are
important. But operator overloading gets a lot of bad press.
</p>

<p>
It seems to be viewed as something that is easily abused and rarely used to good
effect. I want to tell you why I think it's really good and offer some
principles.
</p>

</aside>

</section>
<section id="slide-org509561e">
<h3 id="org509561e">Expressive user-defined types</h3>
<div class='vertspace2'></div>
<p>
Regular types are great!
</p>

<p>
Operators give us compositional style with concision.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">which would you rather see?</span>

<span style="color: #006400;">// </span><span style="color: #006400;">option 1</span>
a = <span style="color: #a020f0;">operator</span>+<span style="color: #707183;">(</span>x, <span style="color: #a020f0;">operator</span>*<span style="color: #7388d6;">(</span>y, z<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">option 2</span>
a = x + y * z;
</pre>
</div>

<aside class="notes">
<p>
Potentially huge readability gain here.
</p>

<p>
Let's explore the boundaries a bit.
</p>

</aside>

</section>
<section id="slide-org2d3bc73">
<h3 id="org2d3bc73">Command-Line Parsing: Clara</h3>
<div class='vertspace2'></div>
<p>
Phil Nash: <i>A Composable Command Line Parser</i>
</p>

<p>
(CppCon 2017 Lightning Talks)
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">cli</span>
  = ExeName<span style="color: #707183;">(</span> config.processName <span style="color: #707183;">)</span>
  | Help<span style="color: #707183;">(</span> config.showHelp <span style="color: #707183;">)</span>
  | Opt<span style="color: #707183;">(</span> config.listTests <span style="color: #707183;">)</span>
      <span style="color: #707183;">[</span><span style="color: #b22222;">"-l"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"--list-tests"</span><span style="color: #707183;">]</span>
      <span style="color: #707183;">(</span> <span style="color: #b22222;">"list all/matching test cases"</span> <span style="color: #707183;">)</span>
  | Opt<span style="color: #707183;">(</span> config.listTags <span style="color: #707183;">)</span>
      <span style="color: #707183;">[</span><span style="color: #b22222;">"-t"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"--list-tags"</span><span style="color: #707183;">]</span>
      <span style="color: #707183;">(</span> <span style="color: #b22222;">"list all/matching tags"</span> <span style="color: #707183;">)</span>
  <span style="color: #0000ff;">...</span>
</pre>
</div>
<p>
<a href="https://www.youtube.com/watch?v=Od4bjLfwI-A">https://www.youtube.com/watch?v=Od4bjLfwI-A</a>
</p>

<aside class="notes">
<p>
This is originally from Catch. A good example of operator overloading.
</p>

<p>
I recommend watching Phil's talk. I think the key is starting with
composability. This inevitable leads you towards unlocking a declarative style.
</p>

<p>
Here again we can see hallmarks of declarative style:
</p>
<ul>
<li>use of expressions</li>
<li>overloading operators</li>
<li>of course, declaration</li>

</ul>

<p>
This code says WHAT very clearly. It doesn't say HOW. It doesn't CARE HOW.
</p>

</aside>

</section>
<section id="slide-org30bb85d">
<h3 id="org30bb85d">Operator overloading advice</h3>
<div class='vertspace2'></div>
<blockquote  class="fragment appear">
<p>"When in doubt, do as the <code>int</code>s do."</p>
<div></div><div class='author'>
<p>
&#x2013; Scott Meyers, <i>More Effective C++</i>
</p>
</div>
</blockquote>
<br clear="all"/>
<blockquote  class="fragment appear">
<p>
"It is probably wise to use operator overloading primarily to mimic conventional
use of operators."
</p>
<div></div><div class='author'>
<p>
&#x2013; Bjarne Stroustrup, <i>The C++ Programming Language</i>
</p>
</div>
</blockquote>
<br clear="all"/>
<aside class="notes">
<p>
Arguments against operator overloading:
</p>

<p>
People don't like re-using operators to mean arbitrary, nonconventional things.
(cf trademarks)
</p>

<p>
People don't like the potential for operators to impose performance costs
through hidden computation and through binary functions calls rather than n-ary.
</p>

</aside>

</section>
<section id="slide-org7ff3d8c">
<h3 id="org7ff3d8c">Operator overloading</h3>
<div class='vertspace2'></div>
<p>
When in doubt, do what <code>operator+</code> does?
</p>

<aside class="notes">
<p>
Maybe we should try to find the most "normal" operator and see if we can divine
some guidelines for overloading.
</p>

</aside>

</section>
<section id="slide-org5646276">
<h3 id="org5646276"><code>operator+</code> Properties</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Property</td>
<th class="org-left">Math(s)</td>
<th class="org-left">C++</td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="1">Closed</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="1">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="5">&#x2717; (overflow)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="2">Associative</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="2">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="6">&#x2717; (floating point)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="3">Commutative</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="3">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="7">&#x2717; (strings)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="4">Has Identity</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="4">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="8" style="float: inline-start;">&#x2714;</div><div class="fragment" data-fragment-index="13">&#x2714;(+0.0, -0.0!)</div></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
This tells me that programming has its own conventions separate from the
conventions of mathematics.
</p>

<p>
On the other hand, we do try to follow mathematical conventions mostly.
</p>

<p>
In C++, equality is an equivalence relation. Unlike in Javascript.
</p>

</aside>

</section>
<section id="slide-org7ec3766">
<h3 id="org7ec3766">C++ Operator Conventions</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Operator(s)</td>
<th class="org-left">Convention</td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="1"><code>==</code>  <code>!=</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="2">Math(s)-like</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="3"><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;=&gt;</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="4">Math(s)-like</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="5"><code>+</code> <code>-</code> <code>*</code> <code>/</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="6"><em>Mostly</em> math(s)-like</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="7"><code>|</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="8">Pipelining, monoidal</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="9"><code>-&gt;*</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="10">Expression templates</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="11"><code>&amp;&amp;</code> <code>||</code> <code>,</code></div></td>
<td class="org-left"><div class="fragment" data-fragment-index="12">Just don't</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="13">other</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="13">Open for abuse?</div></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
I like to use unary+ as "conversion to underlying type" on my scoped enums.
</p>

<p>
Overloaded / for path concat is reasonably defensible.
</p>

</aside>

</section>
<section id="slide-orgc3ad982">
<h3 id="orgc3ad982">Operators in Compiler History</h3>
<p>
(from <a href="https://jeffreykegler.github.io/personal/timeline_v3">https://jeffreykegler.github.io/personal/timeline_v3</a>)
</p>
<div class='vertspace2'></div>
<p>
1956: The IT Compiler
</p>
<blockquote  class="fragment appear">
<p>
"&#x2026;the first really <i>useful</i> compiler."
</p>
<div></div><div class='author'>
<p>
&#x2013; Donald E Knuth
</p>
</div>
</blockquote>

<br/>
<p class="fragment appear">
But it didn't have operator precedence as we know it today.
</p>
<blockquote  class="fragment appear">
<p>
"The lack of operator priority &#x2026; in the IT language was the most frequent
single cause of errors by the users of that compiler."
</p>
<div></div><div class='author'>
<p>
&#x2013; Donald E Knuth
</p>
</div>
</blockquote>

<aside class="notes">
<p>
IT (Internal Translator) was a compiler for the IBM 650. Perhaps the first
compiler that we would recognize as one in the modern sense.
</p>

</aside>

</section>
<section id="slide-org1680498">
<h3 id="org1680498">Operator overloading learnings</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">operators communicate properties</li>
<li class="fragment appear">operators make sense for binary functions</li>
<li class="fragment appear">operators should be conventional</li>
<li class="fragment appear">identify your monoids!</li>

</ul>

<aside class="notes">
<p>
Infix notation conveys properties more naturally?
Commutativity, Associativity, Closedness.
</p>

<p>
Infix expressions are more malleable, easier to move around, compose, use parens
to clarify, etc.
</p>

<p>
Compilers can't collapse n functions calls into an n-ary function call. Where
binary functions are the main/only way to compose your types, overloading
operators can make a lot of sense.
</p>

<p>
Shorter = more readable.
</p>

<p>
We get to define our own conventions &#x2013; no need for dogmatic reliance on maths.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc1f7407">
<h2 id="orgc1f7407">Where can we go from here?</h2>
<div class='vertspace2'></div>
<p>
Where is C++ giving declarative code good support?
</p>

<p>
Where can it be improved?
</p>

</section>
</section>
<section>
<section id="slide-org4c862c3">
<h2 id="org4c862c3">Where C++ is Strong</h2>
<div class="outline-text-2" id="text-org4c862c3">
</div>
</section>
<section id="slide-orgdf3932a">
<h3 id="orgdf3932a">RAII, Initialization</h3>
<div class='vertspace2'></div>
<p>
RAII is the bread-and-butter of C++ programming. It's a natural fit for a
declarative style.
</p>

<p>
Initialization is complex, but getting easier.
</p>
<ul>
<li>aggregate initialization</li>
<li>rule of zero</li>
<li>UDLs for extra expressiveness</li>
<li>class template deduction</li>
<li>C++20 designators</li>

</ul>

<aside class="notes">
<p>
Obviously, RAII is all about declaring something and letting the C++ machinery
take care of lifetime. We love it - it's what C++ is about.
</p>

<p>
Initialization is one of those areas of C++ that has been getting a lot of
scrutiny, a fair amount of "bad press" highlighting where it's not good enough
yet, so it's moving pretty strongly.
</p>

</aside>

</section>
<section id="slide-org3ce68e3">
<h3 id="org3ce68e3">Functions &amp; lambdas</h3>
<div class='vertspace2'></div>
<p>
Functions:
</p>
<ul>
<li>turn statements into expressions</li>
<li>give expressions names</li>
<li>encapsulate conditions</li>
<li>are the optimizer's bread and butter</li>

</ul>

<p>
Structured bindings work around single-return-value limitation.
</p>

<aside class="notes">
<p>
Functions are wonderful. Higher order functions are in some sense the FP
equivalent of OO's dependency injection.
</p>

<p>
Structured bindings allow multiple "atomic" declarations.
</p>

<p>
We think about these often in the context of <code>if</code>-initialization, and they do go
well together, but if you're generally trying to avoid conditions,
<code>if</code>-initialization might become less important.
</p>

<p>
But the principle of useful return is important.
</p>

<p>
See also: no raw loops.
</p>

</aside>

</section>
<section id="slide-org293ebb9">
<h3 id="org293ebb9">Overloads &amp; templates</h3>
<div class='vertspace2'></div>
<p>
Parametric polymorphism: enable use of functions without conditionals.
</p>

<p>
Let the compiler do the right thing.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = <span style="color: #228b22;">A</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span><span style="color: #7388d6;">&gt;</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">uniform_int_distribution</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">C</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">numeric_limits</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">B</span><span style="color: #7388d6;">&gt;</span>::max<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>
  -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_integral_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">C</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">D</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> D<span style="color: #7388d6;">(</span>a, b<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
Andy Bond: <i>AAAARGH!?</i> (CppCon 2016)
</p>

<p>
<a href="https://www.youtube.com/watch?v=ZCGyvPDM0YY">https://www.youtube.com/watch?v=ZCGyvPDM0YY</a>
</p>

<aside class="notes">
<p>
Adopting Almost-Always-Auto Reinforces Good Habits?
</p>

</aside>

</section>
<section id="slide-orgc5d1900">
<h3 id="orgc5d1900">Overloads &amp; templates</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = <span style="color: #228b22;">A</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span><span style="color: #7388d6;">&gt;</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">uniform_real_distribution</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">C</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = B<span style="color: #7388d6;">{</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>
  -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_floating_point_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">C</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #228b22;">D</span><span style="color: #707183;">&gt;</span>;

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">uniform_duration_distribution</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = <span style="color: #228b22;">A</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span><span style="color: #7388d6;">&gt;</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #228b22;">uniform_duration_distribution</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">C</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">B</span>::max<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">D</span>;
</pre>
</div>

<aside class="notes">
<p>
With relatively little effort, we can make a type-safe uniform distribution for
chrono durations. Really useful for improving call sites and unlocking the
ability for users to be type-safe.
</p>

<p>
I use this all the time in my day job for implementing randomized network
backoffs.
</p>

</aside>

</section>
<section id="slide-org0c4abe2">
<h3 id="org0c4abe2">Other features</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Guaranteed copy elision P0135</li>
<li class="fragment appear">Evaluation order guarantees P0145</li>
<li class="fragment appear">Fold expressions</li>

</ul>

<aside class="notes">
<p>
Guaranteed copy elision: obviously really good for leveraging functions.
</p>

<p>
Evaluation order guarantees are great for the builder pattern we saw earlier.
</p>

<p>
I haven't even mentioned fold expressions. They offer increased flexibility of
interface and the chance to get n-ary application for free with a simple binary
function interface. They magnify the power of operator overloading.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org7ef6c07">
<h2 id="org7ef6c07">Where C++ is weaker</h2>
<div class='vertspace2'></div>
<p>
AKA: write a paper!
</p>

<p>
C++Now is a good place to start&#x2026;
</p>

</section>
<section id="slide-org72179d9">
<h3 id="org72179d9">Inconsistencies</h3>
<div class='vertspace2'></div>
<p>
In C++17, we gained <code>if</code>- and <code>switch</code>-initializers.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">if</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #7388d6;">[</span>it, inserted<span style="color: #7388d6;">]</span> = m.emplace<span style="color: #7388d6;">(</span><span style="color: #b22222;">"Jenny"</span>, <span style="color: #008b8b;">8675309</span><span style="color: #7388d6;">)</span>; inserted<span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
But no love for the expression equivalent of <code>if</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">result</span> =
  <span style="color: #707183;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #7388d6;">[</span>it, inserted<span style="color: #7388d6;">]</span> = m.emplace<span style="color: #7388d6;">(</span><span style="color: #b22222;">"Jenny"</span>, <span style="color: #008b8b;">8675309</span><span style="color: #7388d6;">)</span>; inserted<span style="color: #707183;">)</span>
  ? <span style="color: #006400;">// </span><span style="color: #006400;">some expression ...</span>
  : <span style="color: #006400;">// </span><span style="color: #006400;">some other expression ...</span>
</pre>
</div>

<aside class="notes">
<p>
<code>if</code> and the conditional operator ostensibly do the same thing, but not really.
</p>

<p>
Partly because <code>if</code> is a statement and doesn't need to obey the rules of the
type system in its two branches.
</p>

</aside>

</section>
<section id="slide-org26ccef7">
<h3 id="org26ccef7">Heritage: assignment</h3>
<div class='vertspace2'></div>
<p>
Assignment is an expression.
</p>
<ul>
<li>implementation burden: lvalues</li>
<li><code>operator=</code> must be a member function</li>
<li>but <code>operator@=</code> can be free?</li>
<li>chained assignments? convenient but a smell</li>

</ul>

<p>
Assignment is blurred with construction.
</p>
<ul>
<li>historic: rule of N</li>
<li>conflicting sink parameter advice</li>
<li>now it's worse: move vs copy, reference qualifiers</li>

</ul>

<aside class="notes">
<p>
Assignment operator "has to" return lvalue ref.
</p>

<p>
Remember the previous quote from The C++ Prog lang: "It cannot be overemphasized
that <i>assignment and initialization are different operations</i>."
</p>

<p>
Example from The C++ Programming Language: "The definition of <code>operator+=</code> for
<code>complex</code> cannot be deduced from the definitions of <code>operator+</code> and <code>operator=</code>.
</p>

<p>
But in practice, anyone deviating from the semantics would receive short shrift
in a code review.
</p>

</aside>

</section>
<section id="slide-org5622cd4">
<h3 id="org5622cd4">Type system: "functions"?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">steps</span> = <span style="color: #008b8b;">0</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">f</span> = <span style="color: #707183;">[</span>&amp;<span style="color: #707183;">](</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span> ++steps; <span style="color: #a020f0;">return</span> x / <span style="color: #008b8b;">2</span>; <span style="color: #707183;">}</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">g</span> = <span style="color: #707183;">[</span>&amp;<span style="color: #707183;">](</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span> ++steps; <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">3</span> * x + <span style="color: #008b8b;">1</span>; <span style="color: #707183;">}</span>;

<span style="color: #006400;">// </span><span style="color: #006400;">why doesn't this work?</span>
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">h</span> = <span style="color: #707183;">(</span>x % <span style="color: #008b8b;">2</span> == <span style="color: #008b8b;">0</span><span style="color: #707183;">)</span> ? f : g;
</pre>
</div>

<aside class="notes">
<p>
It doesn't work because we don't have proper function types (which is to say,
function signature types) in the language. We have functions, function pointers,
PMFs, PMDs, lambdas, bind expressions&#x2026;
</p>

<p>
There is a lot of standardese for the conditional operator. But intuitively, we
can see that there isn't a common type between the closure structs here.
</p>

<p>
A function signature is a concept, not a type?
</p>

</aside>

</section>
<section id="slide-orgd862cf1">
<h3 id="orgd862cf1">Heritage: operators</h3>
<div class='vertspace2'></div>
<p>
C++ inherits pretty much all of its operators from C.
</p>

<p>
We also inherit some fixed semantics (despite operator overloading).
</p>

<p>
Operators can be amazing for expressivity of code and declarative constructs.
</p>

<aside class="notes">
<p>
Operators have a huge potential for expressing declarative code.
</p>

<p>
Unfortunately C++ operators are one of parts of the language that gets the least
attention.
</p>

</aside>

</section>
<section id="slide-org994838b">
<h3 id="org994838b">Heritage: operators</h3>
<div class='vertspace2'></div>
<p>
Operators are hard to deal with in C++.
</p>

<ul>
<li class="fragment appear">fixed syntactic set</li>
<li class="fragment appear">fixed precedence</li>
<li class="fragment appear">fixed associativity</li>
<li class="fragment appear">fixed arity</li>
<li class="fragment appear">fixed fixity</li>
<li class="fragment appear">fixed evaluation semantics (which may change on overload)</li>
<li class="fragment appear">ADL</li>

</ul>

<aside class="notes">
<p>
No wonder overloading operators is such an unloved part of the language. No
wonder operator overloading is frowned upon in many circles. We can't make them
mean what they should. We can't make them do what they should. We can't make
them very easy to use. So a lot of people look at operator overloading as syntax
abuse.
</p>

<p>
You get to use operator overloading pretty much if you're concatenating
string-like things, or writing a "numeric" class like a matrix, or providing a
way to print your type.
</p>

<p>
I would love to see some of these shortcomings tackled. Many of these things are
"language rules" that could be expressed in code. Can we do for operators what
metaclasses do for user defined types?
</p>

</aside>

</section>
<section id="slide-org90115a3">
<h3 id="org90115a3">Operator Overloading and Futures</h3>
<div class='vertspace2'></div>
<img src='futures.svg'/>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">imaginary-ish code</span>
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>A<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">(</span>X<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>B<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">g1</span><span style="color: #707183;">(</span>A<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>C<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">g2</span><span style="color: #707183;">(</span>A<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>D<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">h</span><span style="color: #707183;">(</span>B, C<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Imagine a simple composition of asynchronous functions that return futures.
</p>

<p>
Notice that their composition can itself be viewed as a function from X to
future&lt;D&gt;.
</p>

<p>
I'm not making any assumptions about how <code>my_future</code> is implemented here.
</p>

</aside>

</section>
<section id="slide-orgb000955">
<h3 id="orgb000955">Operator Overloading and Futures</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut</span> = f<span style="color: #707183;">()</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">split1</span> = fut.then<span style="color: #707183;">(</span>g1<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">split2</span> = fut.then<span style="color: #707183;">(</span>g2<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut2</span> = when_all<span style="color: #707183;">(</span>split1, split2<span style="color: #707183;">)</span>.then<span style="color: #707183;">(</span>h<span style="color: #707183;">)</span>;
</pre>
</div>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut</span> = f<span style="color: #707183;">()</span> &gt; <span style="color: #707183;">(</span>g1 &amp; g2<span style="color: #707183;">)</span> &gt; h;
</pre>
</div>
<p class="fragment appear">
Operator overloading can clarify the computational structure when combining
futures/promises.
</p>

<aside class="notes">
<p>
When we can use operators to compose futures, it becomes easier to see the
computational structure of the composition.
</p>

<p>
Business logic vs mechanism of concurrency vs strategy of parallelism.
</p>

<p>
The question is, what to use for an operator. This is one of the real problems
with operator overloading: lack of choice almost forces lack of conventionality.
</p>

</aside>

</section>
<section id="slide-org20a7746">
<h3 id="org20a7746">A call to action</h3>
<div class='vertspace2'></div>
<p>
What convention are we going to adopt for monadic operators?
</p>

<p>
The future for <code>future</code> operators is uncertain.
</p>

<p>
Please, let's not abuse more operators like we did with <code>&gt;&gt;</code> and <code>&lt;&lt;</code> for
streams.
</p>

<aside class="notes">
<p>
There is a lot potentially on the table here. We're missing a lot of
expressivity in new areas, especially involving composition of monoidal and
monadic types, because we lack the power in overloading operators.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2338260">
<h2 id="org2338260">Where C++ is getting better</h2>
<div class="outline-text-2" id="text-org2338260">
</div>
</section>
<section id="slide-orgb370453">
<h3 id="orgb370453">"Imperative safety gear"</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">better warnings</li>
<li class="fragment appear">static analysis</li>
<li class="fragment appear"><code>[[nodiscard]]</code> attribute (another default?)</li>
<li class="fragment appear"><code>[[fallthrough]]</code> attribute</li>
<li class="fragment appear"><code>if</code>-initializer</li>

</ul>

<aside class="notes">
<p>
We're starting to get the ability for "compilers" to help us reason about
statement sequencing. And to avoid some of the obvious historical errors.
</p>

<p>
<code>nodiscard</code> on types would prevent the unnamed lock issue.
</p>

<p>
Experiment: use <code>nodiscard</code> on every function! Is it another "wrong way round
default"?
</p>

</aside>

</section>
<section id="slide-org9adc5d0">
<h3 id="org9adc5d0">Heritage: Declaration Syntax</h3>
<div class='vertspace2'></div>
<p>
Something we're too close to to appreciate how painful it is?
</p>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #707183;">(</span>*<span style="color: #a0522d;">daytab</span><span style="color: #707183;">)[</span><span style="color: #008b8b;">13</span><span style="color: #707183;">]</span>;
<span style="color: #228b22;">int</span> *<span style="color: #a0522d;">daytab</span><span style="color: #707183;">[</span><span style="color: #008b8b;">13</span><span style="color: #707183;">]</span>;

<span style="color: #228b22;">char</span> <span style="color: #707183;">(</span>*<span style="color: #7388d6;">(</span>*<span style="color: #a0522d;">x</span><span style="color: #909183;">[</span><span style="color: #008b8b;">3</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)()</span><span style="color: #707183;">)[</span><span style="color: #008b8b;">5</span><span style="color: #707183;">]</span>;
</pre>
</div>

<p>
K&amp;R: <i>5.12 Complicated Declarations</i>
</p>

<blockquote nil>
<p>
"C is sometimes castigated for the syntax of its declarations, particularly ones
that involve pointers to functions."
</p>
</blockquote>
<blockquote nil>
<p>
"&#x2026;because declarations cannot be read left-to-right, and because parentheses
are over-used."
</p>
</blockquote>

<aside class="notes">
<p>
I'm not knocking C here. This was fine in 1972!
</p>

</aside>

</section>
<section id="slide-org0cf2f57">
<h3 id="org0cf2f57">Declaration Syntax Help</h3>
<div class='vertspace2'></div>
<p>
Prefer <code>using</code> over <code>typedef</code>.
</p>

<p>
Prefer trailing return syntax in aliases.
</p>

<p>
Think of <code>auto(*)</code> as a token that means "pointer-to-function".
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> <span style="color: #707183;">(</span>*<span style="color: #228b22;">FP</span><span style="color: #707183;">)(</span><span style="color: #228b22;">float</span>, <span style="color: #228b22;">string</span><span style="color: #707183;">)</span>;

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">FP</span> = <span style="color: #a020f0;">auto</span><span style="color: #707183;">(</span>*<span style="color: #707183;">)</span> <span style="color: #707183;">(</span><span style="color: #228b22;">float</span>, string<span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">int</span>;
</pre>
</div>

</section>
<section id="slide-org29453a7">
<h3 id="org29453a7">Richness of library help</h3>
<div class='vertspace2'></div>
<p>
Seemingly-unimportant helper functions (or metafunctions) can be very important
in avoiding conditionals.
</p>

<ul>
<li class="fragment appear"><code>std::exchange</code></li>
<li class="fragment appear"><code>std::as_const</code></li>
<li class="fragment appear"><code>std::apply</code></li>
<li class="fragment appear">expanding <code>type_traits</code></li>
<li class="fragment appear">monadic interface to <code>std::optional</code></li>

</ul>

<aside class="notes">
<p>
I love <code>std::exchange</code> - one of the most underappreciated functions in the STL.
</p>

<p>
When you start trying to deliberately limit use of statements and program more
declaratively, the use for these types of functions becomes more apparent.
</p>

</aside>

</section>
<section id="slide-org4b3b121">
<h3 id="org4b3b121">Richness of library help</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">decltype</span><span style="color: #707183;">(</span><span style="color: #a020f0;">auto</span><span style="color: #707183;">)</span> <span style="color: #0000ff;">identity</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">t</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::forward<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;(</span>t<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">always</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">t</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>x = <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #909183;">&gt;(</span>t<span style="color: #909183;">)</span><span style="color: #7388d6;">](</span><span style="color: #a020f0;">auto</span><span style="color: #0000ff;">...</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> x; <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
These are examples of a couple functions that exist in functional languages.
Again, the use of them isn't obvious to non-declarative programmers. Often the
use lies in getting rid of conditionals.
</p>

<p>
std::identity was in the original SGI STL.
</p>

<p>
If you do TMP, you're probably used to the idea of needing these kinds of
metafunctions. TMP doesn't have assignment, so it's by nature a lot more
declarative. <code>common_type_t</code> with a single argument is often used as the
identity function.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgae57d33">
<h2 id="orgae57d33">Guidelines for Declarative Code</h2>
<div class='vertspace2'></div>

<p>
Meta-guideline <i>reductio</i>: avoid writing statements.
</p>

<p>
(Principally control-flow and assignment.)
</p>

</section>
<section id="slide-orge0cfb65">
<h3 id="orge0cfb65">Replacing Conditionals</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Style</td>
<th class="org-left">Signature Element</td>
<th class="org-left">Elimination Strategy</td>
</tr>
<tr>
<td class="org-left">Imperative</td>
<td class="org-left"><div class="fragment" data-fragment-index="1">Statement</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="2">multi-computation</div></td>
</tr>
<tr>
<td class="org-left">Object-Oriented</td>
<td class="org-left"><div class="fragment" data-fragment-index="3">Object construction</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="4">polymorphism</div></td>
</tr>
<tr>
<td class="org-left">Functional</td>
<td class="org-left"><div class="fragment" data-fragment-index="5">Function call</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="6">higher order function</div></td>
</tr>
<tr>
<td class="org-left">Generic</td>
<td class="org-left"><div class="fragment" data-fragment-index="7">Type instantiation</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="8">traits class</div></td>
</tr>
</tbody>
</table>

<div class='vertspace2'></div>
<p data-fragment-index="9" class="fragment appear">
The Conditional-Replacement Meta-Pattern.
</p>

<aside class="notes">
<ul>
<li>fsel intrinsic on XBox 360</li>
<li>null object pattern</li>
<li>std::sort comparator</li>
<li><code>pointer_traits</code></li>

</ul>

<p>
This metapattern unlocks composition in all these cases. Because it turns
statements into expressions suitable for the domain.
</p>

</aside>

</section>
<section id="slide-orgc3261f0">
<h3 id="orgc3261f0">Replacing Conditionals</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Push conditionals down the callstack
<ul>
<li>intrinsic to data structures</li>
<li>optional/monadic interface</li>
<li>handle at leaf, don't leak</li>

</ul></li>
<li class="fragment appear">Push conditionals up the callstack
<ul>
<li>dependency injection</li>
<li>higher-order functions</li>
<li>power to the caller</li>
<li>lifted to root, abstracted</li>

</ul></li>
<li class="fragment appear">Goal: total functions</li>

</ul>

<aside class="notes">
<p>
Conditions get eliminated, or get pushed up or down the call stack. Pushing down
the call stack encapsulates conditions when there is some intrinsic property of
the data structure that is a condition (like optionality). Pushing up the call
stack and replacing with a behaviour that is passed in gives control to the
caller while keeping the call site declarative.
</p>

<p>
Another way to say it: treat conditionals like we treat errors: handle them and
encapsulate them at the leaf. Or push them up to the root and abstract the
condition in a construct that makes sense for your programming paradigm.
</p>

</aside>

</section>
<section id="slide-org914fb7f">
<h3 id="org914fb7f">Replacing conditionals =&gt; fewer statements</h3>
<div class='vertspace2'></div>
<p>
When you replace/encapsulate conditionals:
</p>
<ul>
<li>less call-site logic (obviously)</li>
<li>simpler, total functions</li>
<li>simpler loops (no break/continue without conditions)</li>
<li>more reason-ability</li>

</ul>

<aside class="notes">
<p>
Fewer conditions in business logic. Total functions.
</p>

</aside>

</section>
<section id="slide-org96d9b1e">
<h3 id="org96d9b1e">Replacing loops =&gt; fewer statements</h3>
<div class='vertspace2'></div>
<p>
No Raw Loops: encapsulate and replace iteration and jumps
</p>
<ul>
<li>less call-site logic</li>
<li>simpler, total functions</li>
<li>more reason-ability</li>
<li>vocabulary grows</li>

</ul>

<aside class="notes">
<p>
You're used to "no raw loops". Algorithms are functions with all the goodness of
functions.
</p>

<p>
Algorithms lock up the statements and reduce the call-site complexity. They work
with edge cases. They have names.
</p>

</aside>

</section>
<section id="slide-org2ca5dd7">
<h3 id="org2ca5dd7">Replacing assignments</h3>
<div class='vertspace2'></div>
<ul>
<li>Declare-at-use
<ul>
<li>use I+LEs</li>
<li>leverage <code>const</code></li>
<li>use AAA-style if you like</li>

</ul></li>
<li>Overload operators for declaration power</li>

</ul>

<aside class="notes">
<ul>
<li>Use I+LEs where appropriate for initialization</li>
<li>Leverage the power of <code>return</code></li>
<li>Operator overloading can be great and can communicate things about your types
that are otherwise hidden</li>

</ul>

</aside>

</section>
<section id="slide-org2ad8120">
<h3 id="org2ad8120">Let the language help</h3>
<div class='vertspace2'></div>
<p>
Where you can't avoid statements, use "imperative safety gear"
</p>
<ul>
<li><code>nodiscard</code> attribute</li>
<li><code>if</code>-initializer</li>
<li>static analysis</li>

</ul>

<aside class="notes">
<p>
C++ is multiparadigm. Don't let declarative style be your only hammer, except as
an exercise in discovery.
</p>

<p>
Imperative safety gear is great. And if you can find a way not to need it,
that's great too.
</p>

</aside>

</section>
<section id="slide-orgc7710e6">
<h3 id="orgc7710e6">Declarative Interfaces</h3>
<div class='vertspace2'></div>
<ul>
<li>dependency injection</li>
<li>higher-order functions</li>
<li>builder pattern / fluent style</li>
<li>identify monoids</li>
<li>start with composition</li>

</ul>

<aside class="notes">
<ul>
<li>Let callers encapsulate conditions, abstract choices</li>
<li>Consider builder/fluent-style with the earlier guidelines</li>
<li>Identify monoids - this will inform operator overloading and lead you to an
easy-to-use, compositional style</li>

</ul>

</aside>

</section>
<section id="slide-org69cd0b8">
<h3 id="org69cd0b8">Declarative Goals</h3>
<div class='vertspace2'></div>
<p>
Expressions over statements.
</p>

<p>
Declarations over assignments.
</p>

<p>
Unconditional code.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
