<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Easy to Use, Hard to Misuse</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<link rel="stylesheet" href="./emoji.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><div class='vertspace6'/><h3>Easy to Use, Hard to Misuse</h3><h2>Declarative Style in C++</h2></div><h3>Ben Deane / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h4>CppCon / Friday September 28th, 2018</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org5cd82ce">
<h2 id="org5cd82ce">In This Talk</h2>
<div class='vertspace2'></div>
<ol>
<li>Definitions &amp; motivation</li>
<li>Where we came from</li>
<li>Where we are</li>
<li>Where we could be headed</li>

</ol>

<aside class="notes">
<p>
I'm going to try to look at the history of programming and C++ and the current
practices that exist, and I'm going to look through a declarative lens.
</p>

<p>
The goal is to see how to apply declarative programming principles to make our
C++ better, in the context of this large, multiparadigm language that isn't
necessarily always amenable to naive pure functional declarative techniques.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6387511">
<h2 id="org6387511">What Do We Mean?</h2>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"A programming paradigm &#x2026; that expresses the logic of a computation without
describing its control flow."
</p>
<div></div><div class='author'>
<p>
&#x2013; Declarative programming page on Wikipedia
</p>
</div>
</blockquote>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"Often it involves the separation of 'facts' from operations on the facts."
"&#x2026; generalizes the pure functional model."
</p>
<div></div><div class='author'>
<p>
&#x2013; wiki.c2.com
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Removing control flow complexity is an important idea.
</p>

<p>
Order of statements should not affect semantics. (Lack of internal/temporal dependencies)
</p>

<p>
Replication of statements should not affect semantics. (Idempotency)
</p>

<p>
These ideas are key to the promise of declarative style: when we write in a
declarative style, it's often easier to convince ourselves that the code is
correct. And we'll see examples of that.
</p>

</aside>

</section>
<section id="slide-orgff1ae60">
<h3 id="orgff1ae60">Declarative Style Indicators</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">referential transparency</li>
<li class="fragment appear">say WHAT in preference to HOW</li>
<li class="fragment appear">minimize imperative style</li>
<li class="fragment appear">declaring things</li>
<li class="fragment appear">expressions over statements</li>

</ul>

<aside class="notes">
<p>
Declarative style is not a hard-and-fast thing, especially not in C++. It's
rather a way of tailoring the code.
</p>

<p>
It's about a preference of style in the service of reason-ability. At the risk
of being etymologically reductive, in part it's a preference for using
declarations.
</p>

<p>
Next: Expressions vs Statements
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge256316">
<h2 id="orge256316">Expressions vs Statements</h2>
<aside class="notes">
<p>
Let's compare and contrast and see what we can discover.
</p>

<p>
What does the standard say?
</p>

</aside>

</section>
<section id="slide-orgec60a91">
<h3 id="orgec60a91">Expressions</h3>
<div class='vertspace2'></div>
<p>
"An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side effects." [expr.pre] &sect; 1
</p>
<div class='vertspace2'></div>
<p>
Properties of expressions:
</p>
<ul>
<li class="fragment appear">value category</li>
<li class="fragment appear">type</li>

</ul>

<aside class="notes">
<p>
The standard has a lot to say about expressions in general before even going
into detail about kinds of expressions and how to make them.
</p>

<p>
There is the familiar value-category tree (lvalue, xvalue, prvalue, etc), which
has "expression" at its root.
</p>

<p>
Expressions have intrinsic properties that can be reasoned about.
</p>

<p>
There is also "context dependence" which is to do with unevaluated contexts and
evaluation for side effects only. A bit of standardese, really.
</p>

</aside>

</section>
<section id="slide-orgbb36a57">
<h3 id="orgbb36a57">Expressions Compose On Multiple Axes</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">expr</span> = a @ b @ c;
</pre>
</div>
<div class='vertspace2'></div>
<p>
Consider this snippet.
</p>

<p>
(@ stands for any operator)
</p>

<aside class="notes">
<p>
There are at least two obvious kinds of composition going on here.
</p>

<p>
a, b, and c have values. expr has a value.
</p>

<p>
a, b, and c have types. expr has a type.
</p>

<p>
Expressions compose on the value axis, and also on the type axis.
Value-composition happens at runtime, and type composition happens at
compile-time. So it can be checked.
</p>

</aside>

</section>
<section id="slide-org8684390">
<h3 id="org8684390">Statements</h3>
<div class='vertspace2'></div>
<p>
"Except as indicated, statements are executed in sequence." [stmt.stmt] &sect; 1
</p>
<div class='vertspace2'></div>
<p>
Properties of statements:
</p>
<ul>
<li class="fragment appear">er&#x2026;</li>

</ul>

<aside class="notes">
<p>
The standard doesn't have a lot to say about statements in general. They are
defined extrinsically, simply by enumerating the different kinds of statements
that we can write.
</p>

<p>
There are no real intrinsic properties of statements.
</p>

</aside>

</section>
<section id="slide-org71c4c46">
<h3 id="org71c4c46">Statements "Compose" Only By Sequencing</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++">x;
y;
z;
</pre>
</div>
<ul>
<li>no type checking</li>
<li>value checking is manual, intrusive</li>
<li>implicit constraints</li>
<li>temporal reasoning is poor</li>

</ul>

<aside class="notes">
<p>
Statements "compose" only by sequencing. There is no direct way to constrain this.
No type checking.
</p>

<p>
Some value checking is done with asserts. I say intrusive because assert itself
is a statement; asserting expressions doesn't change the expressions, but
asserting statements changes the flow of statements.
</p>

<p>
We have (varyingly implicit) constraints with pre- and post-conditions, and
variable lifetime extents. We use variable scoping to control things.
</p>

<p>
Dijkstra: "Our intellectual powers are rather geared to master static relations
and our powers to visualize processes evolving in time are relatively poorly
developed."
</p>

<p>
Carmack: "A large fraction of the flaws in software development are due to
programmers not fully understanding all the possible states their code may
execute in."
</p>

</aside>

</section>
<section id="slide-orgdead5d4">
<h3 id="orgdead5d4">Imperative Safety Gear</h3>
<div class='vertspace2'></div>
<p>
Many of our guidelines, best practices, idioms, and much of our tooling,
analysis, and brainpower work in service of checking the implicit constraints
around statement "composition".
</p>

<aside class="notes">
<p>
We put a lot of effort into controlling statements!
</p>

<p>
We make conventions. We make guidelines.
</p>

<p>
We make tools. We like to run multiple static analysers to get different
benefits from each.
</p>

<p>
We make more tools. We make libraries in support of those tools. We add things
to the language (like contracts) to help us manage this problem. There are great
minds working to bring formal reasoning to statement flow.
</p>

<p>
This is all well and good, but here's an alternative: use fewer statements and
more expressions.
</p>

</aside>

</section>
<section id="slide-org8cd9e2c">
<h3 id="org8cd9e2c">Declarative Style: Avoid Statements!</h3>
<div class='vertspace2'></div>
<ul>
<li>expression statement</li>
<li>selection statement (<code>if</code>, <code>switch</code>)</li>
<li>iteration statement (<code>for</code>, <code>while</code>, <code>do</code>)</li>
<li>jump statement (<code>break</code>, <code>continue</code>, <code>return</code>, <code>goto</code>)</li>
<li>declaration statement</li>

</ul>

<aside class="notes">
<p>
Declarative style is essentially a preference for avoiding statements.
</p>

<p>
Here are the statements available to us. (For the language lawyers, I left out
compound statements (if we get rid of other statements, we mostly get rid of
them), try blocks and atomic/synchronized blocks from the TM TS.) Only the last
of these (declaration statement) is good.
</p>

<p>
As a goal, we should try to avoid most of the rest where we can. It's not a
hard-and-fast rule; it's a goal.
</p>

<p>
Avoiding statements may sound odd at first. But I hope to show that when we look
at current practice through this lens, we'll see that it's what we're already
doing, even if we don't realise it.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org23bdf34">
<h2 id="org23bdf34">Let's Examine History&#x2026;</h2>
<div class='vertspace2'></div>
<p>
Let's look at where we've come from, and see how it informs moving to
declarative style.
</p>

<aside class="notes">
<p>
Let's look first at expression statements.
</p>

<p>
The easiest target.
</p>

<p>
"Most statements in a typical C++ program are expression statements, such as
assignments or function calls." &#x2013; cppreference.com
</p>

</aside>

</section>
<section id="slide-orgb8ae6ef">
<h3 id="orgb8ae6ef">World's Last Bug</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>)
{
  status = GetRadarInfo();
  <span style="color: #a020f0;">if</span> (status = 1)
    LaunchMissiles();
}
</pre>
</div>
<p>
Ancient history you say?
</p>

<aside class="notes">
<p>
Assignment is the king of expression statements.
</p>

<p>
Two odd things here. Let's digress a bit and consider how history brought us to
the current situation.
</p>

</aside>

</section>
<section id="slide-orgf6915e5">
<h3 id="orgf6915e5">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<p>
Assignment as an expression is a historical choice.
</p>

<p>
It's doing us no favours today.
</p>

<p>
Assignment should be a statement.
</p>

<aside class="notes">
<p>
This is my opinion; I don't know whether this is a particularly controversial
thing to say. Based on the practices I see, I don't think so.
</p>

<p>
Some languages make a hard distinction between expressions and statements. C++
doesn't: in C++, expressions are statements too. It's a so-called
expression-oriented language. But this didn't start with C++ or C:
expression-oriented languages have been around for a long time. Notably early
ones were ALGOL-68 (1968) and LISP (1958).
</p>

<p>
So we need to go back a bit.
</p>

</aside>

</section>
<section id="slide-orgf96a3ad">
<h3 id="orgf96a3ad">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">/* </span><span style="color: #006400;">The following function will print a non-negative number, n, to</span>
<span style="color: #006400;">   the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that</span>
<span style="color: #006400;">   in the ASCII character set, the digits 0 to 9 have sequential</span>
<span style="color: #006400;">   code values.  </span><span style="color: #006400;">*/</span>
<span style="color: #0000ff;">printn</span>(n, b) {
    <span style="color: #228b22;">extrn</span> <span style="color: #a0522d;">putchar</span>;
    <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">a</span>;

    <span style="color: #a020f0;">if</span> (a = n / b)
        printn(a, b); <span style="color: #006400;">/* </span><span style="color: #006400;">recursive </span><span style="color: #006400;">*/</span>
    putchar(n % b + <span style="color: #8b2252;">'0'</span>);
}
</pre>
</div>

<aside class="notes">
<p>
I had to tell my syntax highlighter that this was C. Does anyone know what
language this is?
</p>

<p>
From the Users' Reference to B by Ken Thompson. (B: 1969)
</p>

<p>
B was descended from Martin Richards' BCPL (1967), which had an assignment
command, not an assignment expression.
</p>

</aside>

</section>
<section id="slide-org14079b5">
<h3 id="org14079b5">Odd Thing #1: Assignments are Expressions</h3>
<div class='vertspace2'></div>
<p>
We've learned to deal with this. But we don't really like it.
</p>
<ul>
<li class="fragment appear">yoda conditions</li>
<li class="fragment appear">compiler warnings</li>
<li class="fragment appear">P0963: discouraged</li>

</ul>

<aside class="notes">
<p>
This is why I don't think it's controversial to say that assignment shouldn't be
an expression.
</p>

<p>
This is a holdover from history that we increasingly don't like, and we're
increasingly finding ways to avoid. P0963: structured binding declaration as a
condition.
</p>

</aside>

</section>
<section id="slide-org31dfa19">
<h3 id="org31dfa19">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">/* </span><span style="color: #006400;">The following function will print a non-negative number, n, to</span>
<span style="color: #006400;">   the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that</span>
<span style="color: #006400;">   in the ASCII character set, the digits 0 to 9 have sequential</span>
<span style="color: #006400;">   code values.  </span><span style="color: #006400;">*/</span>
<span style="color: #0000ff;">printn</span>(n, b) {
    <span style="color: #228b22;">extrn</span> <span style="color: #a0522d;">putchar</span>;
    <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">a</span>;

    <span style="color: #a020f0;">if</span> (a = n / b)    <span style="color: #006400;">/* </span><span style="color: #006400;">assignment, not test for equality </span><span style="color: #006400;">*/</span>
        printn(a, b); <span style="color: #006400;">/* </span><span style="color: #006400;">recursive </span><span style="color: #006400;">*/</span>
    putchar(n % b + <span style="color: #8b2252;">'0'</span>);
}
</pre>
</div>

<aside class="notes">
<p>
The same snippet of B.
</p>

<p>
Note the comment I left in this time. We're used to this today. But it's worth
asking why it is that way.
</p>

</aside>

</section>
<section id="slide-org85e2c37">
<h3 id="org85e2c37">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"A notorious example for a bad idea was the choice of the equal sign to denote
assignment."
</p>
<div></div><div class='author'>
<p>
&#x2013; Niklaus Wirth
</p>
</div>
</blockquote>

<aside class="notes">
<p>
"Because it overthrows a century old tradition to let “=” denote a comparison
for equality, a predicate which is either true or false."
</p>

<p>
"the operands are on unequal footing &#x2026; x = y does not mean the same thing as y = x."
</p>

<p>
From this I conclude that Niklaus Wirth is not really a fan of operator
overloading. We'll come back to this idea later.
</p>

</aside>

</section>
<section id="slide-org0b178af">
<h3 id="org0b178af">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Superplan (1951) introduced <code>=</code> for assignment</li>
<li class="fragment appear">FORTRAN (1957) used <code>=</code> (because <code>.GT.</code> <code>.LT.</code> <code>.EQ.</code> etc)</li>
<li class="fragment appear">ALGOL-58 introduced <code>:=</code> (assignment) distinct from <code>=</code> (equality)
<ul>
<li>Subsequently many languages went this way</li>

</ul></li>
<li class="fragment appear">BCPL (1967) used <code>:=</code></li>
<li class="fragment appear">B (1969) simplified a lot of BCPL syntax, went with <code>=</code>
<ul>
<li>Followed by C (1972) and many other languages</li>

</ul></li>

</ul>

<aside class="notes">
<p>
The 50s and 60s was an incredible time for programming language innovation.
Superplan introduced the for loop!
</p>

<p>
FORTRAN had to use a very restricted character set. There were no greater than
or less than symbols, hence the idiosyncratic relational operators and the
freeing up of equals for assignment.
</p>

<p>
B is responsible for almost all the operators we have in C++ today.
</p>

</aside>

</section>
<section id="slide-org2dcf0bc">
<h3 id="org2dcf0bc">Odd Thing #2: = Means Assignment</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>
"Since assignment is about twice as frequent as equality testing
in typical programs, it’s appropriate that the operator be half as long."
</p>
<div></div><div class='author'>
<p>
&#x2013; Ken Thompson
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Ken Thompson wanted to fit BCPL on the PDP-7. BCPL's compiler at the time was
16k. PDP-7 had 4k of memory. So Ken cut down the number of characters in source
wherever he could.
</p>

</aside>

</section>
<section id="slide-orgd9b8735">
<h3 id="orgd9b8735">Declaration vs (Re-)Assignment</h3>
<div class='vertspace2'></div>
<p>
In moving from BCPL to B, the distinction between
</p>

<p>
declaration and reassignment was blurred.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 42; <span style="color: #006400;">// </span><span style="color: #006400;">declaration/initialization</span>

a = 1729; <span style="color: #006400;">// </span><span style="color: #006400;">assignment</span>
</pre>
</div>

<blockquote nil>
<p>
"It cannot be overemphasized that <b>assignment and initialization are different
operations</b>."
</p>
<div></div><div class='author'>
<p>
&#x2013; Bjarne Stroustrup, <i>The C++ Programming Language</i>
</p>
</div>
</blockquote>

<aside class="notes">
<p>
Early languages (50s and 60s) often distinguished const-declaration from
variable-decl-and-assignment. ALGOL-68 for example. Pascal-type languages still
do.
</p>

<p>
Consider <code>int</code> here replaced with <code>let</code>, and you have a mathematical declaration
or variable introduction. A mathematical assignment is nonsensical.
</p>

<p>
This distinction was clear in BCPL, which uses = for declaration and := for
reassignment. But the cutting-down-for-memory of B introduced ambiguity.
</p>

</aside>

</section>
<section id="slide-orgc95e4fc">
<h3 id="orgc95e4fc">&lt;End of Historical Diversion&gt;</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Declaring things is &#x2013; has always been &#x2013; fine.</li>
<li class="fragment appear">Declaration and assignment are different things that look the same.</li>
<li class="fragment appear">Assignment as an expression statement is best avoided.
<ul>
<li>Chained assignments are a syntactic laziness.</li>

</ul></li>

</ul>

<aside class="notes">
<p>
What does a look at history tell us about programming style, especially
declarative style?
</p>

<p>
Assignment as an expression is a lazy convenience that doesn't do us any
favours. Expression statements have always been a trap for the unwary.
</p>

<p>
That's why we have warnings for things like this. And that's why we have things
like if-initializers and nodiscard attributes.
</p>

<p>
I can think of no reason to use chained assignments. I grepped my code base and
found zero occurrences.
</p>

</aside>

</section>
<section id="slide-org08e3a66">
<h3 id="org08e3a66">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-broken_heart"></i></td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Assignment used as an expression per se is looking on shaky ground.
We don't like it.
</p>

<ul>
<li>-wunused-value ("statement has no effect")</li>
<li>yoda conditions</li>

</ul>

<p>
Best avoided. Prefer declarations, some of us use AAA, many of us use const
where we can.
</p>

<p>
We guard against expression statements in general: <code>nodiscard</code> attribute in
C++17.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org8bdc0bf">
<h2 id="org8bdc0bf">A Quick Declarative Study</h2>
<aside class="notes">
<p>
Let's look at a fairly common code snippet and examine some different ways to
write it in a modern, potentially declarative style.
</p>

</aside>

</section>
<section id="slide-orgc4f76cb">
<h3 id="orgc4f76cb">Example</h3>
<div class='vertspace2'></div>
<p>
Given:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">weak_ptr</span>&lt;Foo&gt; <span style="color: #a0522d;">wp</span>;
</pre>
</div>
<p>
How to write:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span>;
{
  <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock();
  <span style="color: #a020f0;">if</span> (sp) b = sp-&gt;bar();
}
</pre>
</div>
<p>
In a (more) declarative way.
</p>

<aside class="notes">
<p>
Here is an imperative piece of code. What's wrong with it?
</p>

<ul>
<li>declaration/initialization split (b could well be const after init)</li>
<li>mutable state</li>
<li>scope control (note convention)</li>

</ul>

<p>
This code would likely pass code review. It's the best we can do with imperative
style. It's ticking several guideline boxes. But it's still unsatisfying.
</p>

<p>
I'm using <code>shared_ptr</code> here as a standin for some generic access that requires
this kind of pattern: the pattern is not just for <code>shared_ptr</code>.
</p>

</aside>

</section>
<section id="slide-org5e1199a">
<h3 id="org5e1199a">C++17 if-initializer?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span>;
<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock(); sp)
  b = sp-&gt;bar();
</pre>
</div>
<p>
This still has the declaration/initialization split. Still has mutable state.
</p>

<aside class="notes">
<p>
Note: this is sort of a workaround for the assignment being an expression.
</p>

<p>
I think it likely that this will become a style that replaces the simple
assignment-as-an-expression.
</p>

</aside>

</section>
<section id="slide-orgd2fd465">
<h3 id="orgd2fd465">Conditional operator?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = wp.lock() ? wp.lock()-&gt;bar() : Bar{};
</pre>
</div>
<p>
Hm&#x2026;
</p>

<aside class="notes">
<p>
This is also often known as the ternary operator; the standard calls it the
conditional operator.
</p>

<p>
I think this works? Temporary lives until semicolon? But double lock.
</p>

</aside>

</section>
<section id="slide-org52f5160">
<h3 id="org52f5160">C++?? conditional-operator-initializer?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">this isn't real syntax...</span>
<span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = [<span style="color: #a020f0;">auto</span> sp = wp.lock(); sp] ? sp-&gt;bar() : Bar{};
</pre>
</div>
<p>
Might be nice&#x2026; but not today.
</p>

<aside class="notes">
<p>
Expressions and statements aren't equivalent, even when they "are".
</p>

<p>
Unlike <code>if</code>, syntax doesn't allow us to put a declaration in the condition.
</p>

</aside>

</section>
<section id="slide-orgd3ad6a9">
<h3 id="orgd3ad6a9">GCC Extension?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> =
({
  <span style="color: #a020f0;">auto</span> <span style="color: #228b22;">sp</span> = wp.lock();
  sp ? sp-&gt;bar() : Bar{};
});
</pre>
</div>
<p>
Not ISO C++.
</p>

<aside class="notes">
<p>
GCC has an extension called a statement expression.
</p>

<p>
This is similar to how a compound statement might be handled in a functional
language, where the value of the statement is the value of the last statement in
the body.
</p>

<p>
Of course this leads us to what many of you were already thinking&#x2026;
</p>

</aside>

</section>
<section id="slide-orga8961ed">
<h3 id="orga8961ed">I+LE?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = [&amp;] () {
  <span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sp</span> = wp.lock(); sp) <span style="color: #a020f0;">return</span> sp-&gt;bar();
  <span style="color: #a020f0;">return</span> Bar{};
}();
</pre>
</div>
<p>
Immediately-invoked, inline, initializing, &#x2026;
</p>

<aside class="notes">
<p>
Very much in vogue at the moment.
</p>

<p>
This might be OK? Avoids declaration/initialization split anyway. Depends on
your codebase style.
</p>

</aside>

</section>
<section id="slide-org9e3b701">
<h3 id="org9e3b701">Optional-like?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">b</span> = get_bar_or(wp.lock(), Bar{});
</pre>
</div>
<p>
Not really generic enough.
</p>

<aside class="notes">
<p>
This is a good interface for optional, but (at least until we have reflection)
we can't parameterize over the name of the member variable.
</p>

</aside>

</section>
<section id="slide-org07f400f">
<h3 id="org07f400f">Functorial/Monadic Interface?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">shared_ptr</span>&lt;Bar&gt; <span style="color: #a0522d;">b</span> = fmap(wp.lock(),
                         [] (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">foo</span>) { <span style="color: #a020f0;">return</span> foo.bar(); });
</pre>
</div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>&gt;
[[<span style="color: #008b8b;">nodiscard</span>]] <span style="color: #a020f0;">auto</span> fmap(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">shared_ptr</span>&lt;<span style="color: #228b22;">T</span>&gt;&amp; <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">F</span> <span style="color: #a0522d;">f</span>)
    -&gt; <span style="color: #228b22;">shared_ptr</span>&lt;<span style="color: #228b22;">invoke_result_t</span>&lt;<span style="color: #228b22;">F</span>, <span style="color: #228b22;">T</span>&gt;&gt;
{
  <span style="color: #0000ff;">...</span>
}
</pre>
</div>

<aside class="notes">
<p>
This might be OK? Again depends on your codebase style.
</p>

<p>
Note the nodiscard attribute: another piece of imperative safety gear that helps
us avoid the pitfalls of statements.
</p>

</aside>

</section>
<section id="slide-orgc58bab8">
<h3 id="orgc58bab8">Study Conclusions</h3>
<div class='vertspace2'></div>
<p>
"Total" declarative style is not always achievable in C++.
</p>

<p>
A <i>more</i> declarative style is a reasonable goal.
</p>

<p>
Some features of C++ help us get there.
</p>

<p>
Different domains lean towards different approaches.
</p>

<aside class="notes">
<p>
IILEs help, nodiscard attribute helps
</p>

<p>
Different domains: we probably wouldn't want to use a monadic approach for
<code>shared_ptr</code>. But we might well want to for futures. For errors, the answer
would probably depend on our codebase's existing practice.
</p>

<p>
A key idea is to minimize statements and maximize the use of expressions. This
maximizes the compiler's help.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgaf0d178">
<h2 id="orgaf0d178">Existing Declarative Practice</h2>
<div class='vertspace2'></div>
<p>
We are surrounded by guidelines, goals and idioms.
</p>

<p>
Looking through a declarative lens, we can tie it together.
</p>

</section>
<section id="slide-orgaa02edd">
<h3 id="orgaa02edd">Core Guidelines</h3>
<div class='vertspace2'></div>
<p>
<i><code>Con.1</code></i> By default, make objects immutable.
</p>

<p>
<i><code>Con.4</code></i> Use <code>const</code> to define objects with values that do not change after
construction.
</p>

<p>
<i><code>ES.21</code></i> Don't introduce a variable (or constant) before you need to use it.
</p>

<p>
<i><code>ES.22</code></i> Don't declare a variable until you have a value to initialize it with.
</p>

<p>
<i><code>ES.28</code></i> Use lambdas for complex initialization.
</p>

<aside class="notes">
<p>
Of course we've been doing ES 21 &amp; 22 forever; the ability to declare variables
at the point of use is one of the things that separates C++ from C.
</p>

<p>
Corollary to <i>Con.4</i>: we probably have lots of objects that can be <code>const</code>.
</p>

<p>
Just watch a few episodes of C++Weekly&#x2026;
</p>

</aside>

</section>
<section id="slide-orgfb62c31">
<h3 id="orgfb62c31">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
We try to avoid assignment after initialization: assignment as an expression.
</p>

<p>
This allows us to take advantage of immutability for correctness and
performance, and optimizations like RVO.
</p>

<p>
This also reduces the need for scoping auxiliary variables and therefore reduces
the need for compound statements.
</p>

</aside>

</section>
<section id="slide-org7972b61">
<h3 id="org7972b61">Functions in General</h3>
<div class='vertspace2'></div>
<p>
We like to put things in functions.
</p>

<ul>
<li>shorter is more expressive, understandable</li>
<li>encapsulation of variable scopes, lifetimes, concerns</li>
<li>functions give things names</li>

</ul>

<aside class="notes">
<p>
These are the normal reasons given for liking functions.
</p>

<p>
And they're great. I like functions for all these reasons.
</p>

</aside>

</section>
<section id="slide-orga228ae0">
<h3 id="orga228ae0">Another Reason to like Functions</h3>
<div class='vertspace2'></div>
<p>
Functions turn statements into expressions.
</p>

<ul>
<li><code>return</code> is the socially acceptable <code>goto</code></li>
<li>way better than <code>break</code></li>
<li>and if that wasn't enough, RVO</li>

</ul>

<aside class="notes">
<p>
I am not a fan of "one exit path per function". I don't think this is a
particularly controversial point of view. In C++ it's an antipattern. When you
have RAII, you don't need this!
</p>

<p>
Early-outs make for shallow, simple conditions. <code>return</code> can very simply cut out
of find-style algorithms.
</p>

<p>
According to one of the top answers on stack overflow, the notion of single-exit
was introduced with Structured Programming as a guard against alternate returns,
which were not returns <i>from</i> multiple places but returns <i>to</i> multiple places.
e.g. in FORTRAN when a function had an error it would do an alternate return to
a place where the error was handled.
</p>

</aside>

</section>
<section id="slide-org9757989">
<h3 id="org9757989">&lt;algorithm&gt;</h3>
<div class='vertspace2'></div>
<p>
"No Raw Loops"
</p>

<p>
What does that mean?
</p>
<ul>
<li>encapsulate iteration statements</li>
<li>encapsulate remaining assignments</li>
<li>encapsulate <code>break</code> and <code>continue</code></li>

</ul>

<aside class="notes">
<p>
Algorithms are essentially declarative: they are functions. They are expressive.
They have names. They declare what's going on.
</p>

<p>
"No raw loops" as a goal is a subset of "strive for declarative code".
</p>

<p>
It exhorts us to take these statement types and push them down out of the
business logic.
</p>

</aside>

</section>
<section id="slide-org1970cb1">
<h3 id="org1970cb1"><code>#include "my_algorithms.h"</code></h3>
<div class='vertspace2'></div>
<ul>
<li><code>min_unused</code></li>
<li><code>is_prefix_of</code></li>
<li><code>join</code></li>
<li><code>transform_if</code></li>
<li><code>set_differences</code> (aka before and after)</li>
<li><code>push_back_unique</code></li>

</ul>

<aside class="notes">
<p>
Here is a selection of algorithms in my toolkit.
</p>

<p>
None of these algorithms is groundbreaking. Some of them are little more than
rebrandings of one-liners. None of them is more than a handful of lines.
</p>

<p>
What they <i>do</i> is avoid statements in logic. They simplify control flow. Notice
also that all well-written algorithms deal with the edge cases: primarily empty
ranges. You don't have to put conditions or loops in your logic!
</p>

</aside>

</section>
<section id="slide-org2699c5c">
<h3 id="org2699c5c">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
So, "no raw loops" is leading us to avoid iteration and jump statements.
</p>

<p>
I+LEs and initialization guidelines lead us to avoid assignments.
</p>

<p>
Let's look now at how to avoid conditions. Hint: we're already doing it.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org553cdf5">
<h2 id="org553cdf5">Declarative Domains and Patterns</h2>
<div class="outline-text-2" id="text-org553cdf5">
</div></section>
<section id="slide-org7140aaa">
<h3 id="org7140aaa">Testing</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++">TEST_CASE( <span style="color: #8b2252;">"Factorials are computed"</span>, <span style="color: #8b2252;">"[factorial]"</span> ) {
    REQUIRE( Factorial(1) == 1 );
    REQUIRE( Factorial(2) == 2 );
    REQUIRE( Factorial(3) == 6 );
}
</pre>
</div>

<p>
Conditions are encapsulated; nothing is dependent.
</p>
<ul>
<li class="fragment appear">idempotent</li>
<li class="fragment appear">minimal temporal dependency between statements</li>
<li class="fragment appear">leverage constructors/RAII</li>
<li class="fragment appear">popularity of sections over fixture management</li>

</ul>

<aside class="notes">
<p>
This is from Catch.
</p>

<p>
Testing use macros to hide constructor/RAII syntax. It also uses global state.
Declarative style isn't incompatible with global state; sometimes you have to do
what you have to do.
</p>

<p>
C++ is a multiparadigm language; declarative style isn't "pure FP or nothing".
</p>

</aside>

</section>
<section id="slide-org069a67d">
<h3 id="org069a67d">Logging : Imperative turned Declarative</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #0000ff;">fprintf</span>(g_debugLogFilep, <span style="color: #8b2252;">"R Tape loading error, %d:%d"</span>, line, stmt);
</pre>
</div>
<p>
vs
</p>
<div class="org-src-container">

<pre  class="src src-c++">LOG(<span style="color: #8b2252;">"R Tape loading error, "</span> &lt;&lt; line &lt;&lt; <span style="color: #8b2252;">':'</span> &lt;&lt; stmt);
</pre>
</div>

<aside class="notes">
<p>
Logging is very often declarative. Nothing much new here, but let's explore a
bit because it's a domain that benefits greatly from declarative practice.
</p>

<p>
We're using overloaded operators. We're using RAII. We've got a declarative,
concatenative style. What has been gained here?
</p>

<p>
Composability: through operator overloading, we have the ability to extend the
expression, because expressions are composable.
</p>

<p>
Extensibility: we can provide the operator for our own types.
</p>

<p>
Type checking: with fprintf, the format string and the arguments have to match
or bad things will happen. Usually the worst we can expect with LOG is that we
get unexpected conversions of the arguments.
</p>

</aside>

</section>
<section id="slide-org5f367bc">
<h3 id="org5f367bc">Where Did the Global Go?</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #006400;">// </span><span style="color: #006400;">g_debugLogFilep is a global variable</span>
<span style="color: #0000ff;">fprintf</span>(g_debugLogFilep, <span style="color: #8b2252;">"R Tape loading error, %d:%d"</span>, line, stmt);
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">somewhere, a "global" variable lurks? where does the log go to?</span>
LOG(<span style="color: #8b2252;">"R Tape loading error, "</span> &lt;&lt; line &lt;&lt; <span style="color: #8b2252;">':'</span> &lt;&lt; stmt);
</pre>
</div>

<aside class="notes">
<p>
Logging framework? What has replaced the global variable? Functions and/or
declarations in the global namespace.
</p>

<p>
A sink is where logs go to. In the C case, <code>g_debugLogFilep</code>. In the C++ case, a
global variable that is hidden inside the RAII object constructed with LOG.
</p>

<p>
The benefits of declarative style outweigh the drawbacks of having a few global
variables for domains like this.
</p>

<p>
But let's look at the log sink interface, because that's another good example of
how current practice is limiting statements.
</p>

</aside>

</section>
<section id="slide-org2ec524f">
<h3 id="org2ec524f">C-Style Log Sink</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c"><span style="color: #0000ff;">fprintf</span>(g_debugLogFilep, <span style="color: #8b2252;">"R Tape loading error, %d:%d"</span>, line, stmt);
</pre>
</div>

<p>
What would we do if we wanted to change where the log went?
</p>

<aside class="notes">
<p>
In the 70s, we would write to stdout and change the destination with the shell
using pipes or tee. This is still perfectly fine if we're writing small console
apps, but if we're writing larger apps, we want more control. The ability to
wrangle logging options at runtime.
</p>

<p>
In the C style we'd probably encapsulate in our own function - likely one of the
v-prefixed printf functions. In OO-style?
</p>

</aside>

</section>
<section id="slide-org408f691">
<h3 id="org408f691">Log Sinks: OO turned Declarative</h3>
<div class='vertspace2'></div>
<p>
A study in compositional design.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Sink</span>
{
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">bool</span> Push(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp; <span style="color: #a0522d;">e</span>);
  <span style="color: #0000ff;">...</span>
};
</pre>
</div>

<aside class="notes">
<p>
A log sink takes the place of the global file pointer. It's an RAII object - on
destruction, the logger object dispatches the log entry to the sink. And it can
add entry information: a timestamp, file, line, etc (this is typically why it's
a macro).
</p>

<p>
So let's talk about log sinks, which is an example of applying declarative style
to a traditionally object-oriented approach. The key is composition.
</p>

<p>
A Sink has one important method: to push an entry. Notice it returns bool
indicating whether or not the entry was actually accepted.
</p>

<p>
With just this basic interface, we have quite a range of choices in sinks we can
make.
</p>

</aside>

</section>
<section id="slide-orgdb5c2f5">
<h3 id="orgdb5c2f5">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">FileSink</span> : <span style="color: #228b22;">Sink</span>
{
  <span style="color: #0000ff;">...</span>
  FileSink(<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">pathname</span>);
  <span style="color: #0000ff;">...</span>
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">DebugSink</span> : <span style="color: #228b22;">Sink</span> { <span style="color: #0000ff;">...</span> };
</pre>
</div>

<aside class="notes">
<p>
At a basic level, we can make different sinks that go to different places. One
to a log file, one to the debug window, maybe one to a listening log aggregator
service over the network.
</p>

</aside>

</section>
<section id="slide-org643f256">
<h3 id="org643f256">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">FilterSink</span> : <span style="color: #228b22;">Sink</span>
{
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Pred</span>&gt;
  FilterSink(<span style="color: #228b22;">Pred</span> <span style="color: #a0522d;">p</span>);
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">using</span> Predicate = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">bool</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp;)&gt;;
  <span style="color: #228b22;">Predicate</span> <span style="color: #a0522d;">pred</span>;
};
</pre>
</div>

<aside class="notes">
<p>
We can also make sinks that inspect the log entry and only accept certain
entries. So we can make a sink that filters entries passed to it.
</p>

</aside>

</section>
<section id="slide-org47af845">
<h3 id="org47af845">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Exercise for the reader: ExecutionPolicy Concept</span>
<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">ExecutionPolicy</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">ExecSink</span> : <span style="color: #228b22;">Sink</span> { <span style="color: #0000ff;">...</span> };
</pre>
</div>

<aside class="notes">
<p>
We can make a sink that wraps another sink and implements an execution policy,
so we can implement threaded logging or deferred flushing.
</p>

</aside>

</section>
<section id="slide-org75710a5">
<h3 id="org75710a5">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">MultiSink</span> : <span style="color: #228b22;">Sink</span>
{
  <span style="color: #0000ff;">...</span>
  <span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">unique_ptr</span>&lt;Sink&gt;&gt; sinks;
};
</pre>
</div>

<aside class="notes">
<p>
We can make a sink that wraps multiple other sinks and passes entries through to
them. And we can parameterize that on whether it will stop at the first
accepting sink, or fan out to all.
</p>

</aside>

</section>
<section id="slide-orge9a87ab">
<h3 id="orge9a87ab">Sink Variations</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">NullSink</span> : <span style="color: #228b22;">Sink</span>
{
  <span style="color: #0000ff;">...</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">bool</span> Push(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Entry</span>&amp;) <span style="color: #a020f0;">override</span> { <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>; }
  <span style="color: #0000ff;">...</span>
};
</pre>
</div>

<aside class="notes">
<p>
We can make a null sink that just returns true from Push().
</p>

<p>
What is the goal with all these variations?
</p>

<p>
Object orientation: tell, don't ask. We're encapsulating conditions using
polymorphism.
</p>

</aside>

</section>
<section id="slide-orgbfe159c">
<h3 id="orgbfe159c">Declarative Sink Construction</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fileSink</span> = [&amp;] () -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span>&lt;Sink&gt; {
  <span style="color: #a020f0;">if</span> (logToFile) {
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::make_unique&lt;FileSink&gt;(generate_filename());
  } <span style="color: #a020f0;">else</span> {
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::make_unique&lt;NullSink&gt;();
  }
}();
</pre>
</div>
<p>
Conditions are encapsulated at the point of construction.
</p>

<p>
The point of use is condition-free and declarative.
</p>

<aside class="notes">
<p>
Good OO style tells us this. We use things like dependency injection and the
null object pattern - they're all about encapsulating conditions inside the
class, pushing the choice up the callstack and removing the condition from the
code that uses the object.
</p>

<p>
And of course here's an I+LE. Great for inlining short factory functions.
Unfortunately the conditional operator can't easily be used here because of the
<code>common_type</code> requirement.
</p>

<p>
I'm using a conventional inheritance structure here to show that declarative
style is not just about value types. Of course you could use an alternative form
of polymorphism like type erasure. It wouldn't change the point here.
</p>

</aside>

</section>
<section id="slide-org6f707c0">
<h3 id="org6f707c0">Declarative Style: Avoiding Statements</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Statement</td>
<th class="org-left">Status</td>
<th class="org-left">Killed by</td>
</tr>
<tr>
<td class="org-left">assignment</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">guidelines</td>
</tr>
<tr>
<td class="org-left">selection</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">paradigm shift</td>
</tr>
<tr>
<td class="org-left">iteration</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">jump</td>
<td class="org-left"><i class="em-svg em-skull_and_crossbones"></i></td>
<td class="org-left">"no raw loops"</td>
</tr>
<tr>
<td class="org-left">declaration</td>
<td class="org-left"><i class="em-svg em-heart"></i></td>
<td class="org-left"></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Compositional patterns like this are the object-oriented way to avoid selection
statements.
</p>

<p>
If we want to turn off logging, we do that at the point of construction. We
don't incur the mental cost of conditions at the point of use.
</p>

<p>
"Killed by paradigm shift" sounds like a way to die in Nethack.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc38d74c">
<h2 id="orgc38d74c">Design Patterns</h2>
<div class="outline-text-2" id="text-orgc38d74c">
</div></section>
<section id="slide-org01a9b54">
<h3 id="org01a9b54">OO Patterns</h3>
<div class='vertspace2'></div>
<p>
Several patterns lean towards declarative style.
</p>

<p>
Many patterns are about replacing conditions with polymorphism.
</p>

<ul>
<li>Null object</li>
<li>Command</li>
<li>Composite</li>

</ul>

<aside class="notes">
<p>
These patterns have long been my favourites, but I didn't really understand why
until I started thinking about how they encourage declarative style.
</p>

<p>
The Null object pattern eliminates conditions, allowing you to write total functions.
</p>

<p>
Command reifies computation and turns behaviour into something that has a type,
that the compiler can reason about.
</p>

<p>
Composite eliminates conditions by allowing us to treat different elements of a
hierarchy the same.
</p>

<p>
These days there is one construction pattern that comes up a lot in declarative
style.
</p>

</aside>

</section>
<section id="slide-org8107e74">
<h3 id="org8107e74">The "Builder Pattern"</h3>
<div class='vertspace2'></div>
<p>
AKA "Fluent Style" (not the original GoF pattern)
</p>

<div class="org-src-container">

<pre  class="src src-c++">FluentGlutApp(argc, argv)
  .withDoubleBuffer().withRGBA().withAlpha().withDepth()
  .at(200, 200).across(500, 500)
  .named(<span style="color: #8b2252;">"My OpenGL/GLUT App"</span>)
  .create();
</pre>
</div>

<blockquote nil>
<p>
"In which the author turns what should be 5 lines of glut calls at the start of
<code>main</code> into 100 lines of buggy OOP."
</p>
<div></div><div class='author'>
<p>
&#x2013; Nicolas Guillemot (via Twitter)
</p>
</div>
</blockquote>

<aside class="notes">
<p>
The wikipedia example for C++ is not compelling. This is not better than the
N lines of single-use code it replaces.
</p>

<p>
Buggy? I'm not sure. But all other things being equal, fewer lines of code are
likely to be more correct. (This isn't fewer lines of code.)
</p>

<p>
Use fluent style where it makes sense: not for single-use code. For code that
will be used a lot. For code where the verbs are few and clear. And for code
where you can make the types work for you.
</p>

<p>
I think I have better examples.
</p>

</aside>

</section>
<section id="slide-orgeff1852">
<h3 id="orgeff1852">Builder Pattern: A Better Example</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Schedule&amp; Schedule::then(interval_t);</span>

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">s</span> = Schedule(<span style="color: #008b8b;">interval</span>::fixed{1s})
  .then(<span style="color: #008b8b;">repeat</span>::n_times{5, <span style="color: #008b8b;">interval</span>::random_exponential{2s, 2.0}})
  .then(<span style="color: #008b8b;">repeat</span>::forever{<span style="color: #008b8b;">interval</span>::fixed{30s}});

<span style="color: #006400;">// </span><span style="color: #006400;">template &lt;typename Timer, typename Task&gt;</span>
<span style="color: #006400;">// </span><span style="color: #006400;">void Schedule::run(Timer, Task);</span>
s.run(timer, task);
</pre>
</div>

<aside class="notes">
<p>
Building a schedule is something that happens all over the code. It's not
single-use. We've got a single verb: then. We've got types helping us out.
</p>

<p>
Fluent style encourages rvalue usage - useful when we can make it limited in
verbosity. Useful when we won't really ever need the lvalues - no reason to make
an interval other than to immediately put it in a schedule.
</p>

<p>
Readability is good. Schedules are correct by construction.
</p>

</aside>

</section>
<section id="slide-org9d52deb">
<h3 id="org9d52deb">Builder Pattern: Help from C++17</h3>
<div class='vertspace2'></div>
<p>
P0145: Refining Expression Evaluation Order for Idiomatic C++
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">f</span>()
{
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">s</span> = <span style="color: #8b2252;">"but I have heard it works even if you don't believe in it"</span>;
  s.replace(0, 4, <span style="color: #8b2252;">""</span>)
   .replace(s.find(<span style="color: #8b2252;">"even"</span>), 4, <span style="color: #8b2252;">"only"</span>)
   .replace(s.find(<span style="color: #8b2252;">" don't"</span>), 6, <span style="color: #8b2252;">""</span>);
  assert(s == <span style="color: #8b2252;">"I have heard it works only if you believe in it"</span>);
}
</pre>
</div>

<aside class="notes">
<p>
Of course in C++17 we get extra help for using fluent-style interfaces.
Evaluation order is now specified so that this works.
</p>

</aside>

</section>
<section id="slide-org5f2eb48">
<h3 id="org5f2eb48">Putting Types to Work</h3>
<div class='vertspace2'></div>
<p>
This "builder pattern" is an ideal place to put strong types to work.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Build a request object</span>
<span style="color: #228b22;">request_t</span> <span style="color: #a0522d;">req</span> = make_request()
  .set_req_field_1(<span style="color: #0000ff;">...</span>)
  .set_req_field_2(<span style="color: #0000ff;">...</span>)
  .set_opt_field(<span style="color: #0000ff;">...</span>)
  .set_opt_field(<span style="color: #0000ff;">...</span>)
  .set_opt_field(<span style="color: #0000ff;">...</span>);

<span style="color: #006400;">// </span><span style="color: #006400;">Use it</span>
send_request(req);
</pre>
</div>

<aside class="notes">
<p>
A typical situation.
</p>

<p>
We could put the required fields in the constructor, but we might not want to
build the request all in one go.
</p>

<p>
What should <code>send_request</code> do with a request that accidentally doesn't have the
required fields? Today it most often will assert, or simply send the request and
get a protocol error.
</p>

<p>
What we want is for it to fail to compile.
</p>

<p>
We want to leverage a key ability of expressions over statements: they compose
on the type axis.
</p>

</aside>

</section>
<section id="slide-org9455338">
<h3 id="org9455338">Putting Types to Work</h3>
<div class='vertspace2'></div>
<p>
The "normal" construct for this behaviour.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span> {
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_req_field_1</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>) {
    f1 = f;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  }
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_req_field_2</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>);
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_opt_field</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>);

  <span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f1</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">etc ...</span>
};

<span style="color: #228b22;">request_t</span> <span style="color: #0000ff;">make_request</span>() { <span style="color: #0000ff;">...</span> }
</pre>
</div>

<aside class="notes">
<p>
What we want here is to encode the fact that the required fields have been set
(or not) in the type of the request object.
</p>

<p>
Values flow through the computation at runtime; types flow through the
computation at compile-time.
</p>

<p>
We want setting required fields to return a different type. Setting optional
fields should return the same type.
</p>

<p>
We also want setting fields to be idempotent in the type.
</p>

</aside>

</section>
<section id="slide-orgbda05c2">
<h3 id="orgbda05c2">Behaviour in the Type</h3>
<div class='vertspace2'></div>
<p>
One way: use a bitfield.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">OPT_FIELDS</span> = 1 &lt;&lt; 0;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">REQ_FIELD1</span> = 1 &lt;&lt; 1;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">REQ_FIELD2</span> = 1 &lt;&lt; 2;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">ALL_FIELDS</span> = OPT_FIELDS | REQ_FIELD1 | REQ_FIELD2;
</pre>
</div>

<aside class="notes">
<p>
We're going to encode which fields have been set in a bitfield.
</p>

</aside>

</section>
<section id="slide-org3690323">
<h3 id="org3690323">Behaviour in the Type</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span>&gt;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span>;

<span style="color: #a020f0;">template</span> &lt;&gt;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span>&lt;0&gt;
{
  <span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f1</span>;
  <span style="color: #006400;">// </span><span style="color: #006400;">etc ...</span>
};

<span style="color: #a020f0;">template</span> &lt;<span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span>&gt;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">request_t</span> : <span style="color: #228b22;">request_t</span>&lt;N-1&gt;
{
  <span style="color: #228b22;">request_t</span>&lt;N &amp; ~REQ_FIELD1&gt;&amp; <span style="color: #0000ff;">set_req_field1</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>) {
    <span style="color: #a020f0;">this</span>-&gt;f1 = f;
    <span style="color: #a020f0;">return</span> *<span style="color: #a020f0;">this</span>;
  }
  <span style="color: #228b22;">request_t</span>&lt;N &amp; ~REQ_FIELD2&gt;&amp; <span style="color: #0000ff;">set_req_field2</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>);
  <span style="color: #228b22;">request_t</span>&amp; <span style="color: #0000ff;">set_opt_field</span>(<span style="color: #228b22;">field_t</span> <span style="color: #a0522d;">f</span>);
};
</pre>
</div>

<aside class="notes">
<p>
Data members in the base class.
</p>

<p>
Clearing bits in a bitfield is idempotent. The return type of <code>set_req_field_1</code>
might be the same as the type of the this.
</p>

<p>
Clearing bits reduces the non-type template parameter. And through recursion
everything inherits. Finally we get down to the class with only optional fields
left unset, and we can never go below that.
</p>

</aside>

</section>
<section id="slide-org4fd5250">
<h3 id="org4fd5250">Behaviour in the Type</h3>
<div class='vertspace2'></div>
<p>
Use <code>=delete</code> to enable the <code>send_request</code> function only for a
correctly-filled-in request.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">request_t</span>&lt;ALL_FIELDS&gt; <span style="color: #0000ff;">make_request</span>();

<span style="color: #a020f0;">template</span> &lt;<span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">N</span>&gt;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_request</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">request_t</span>&lt;N&gt;&amp; <span style="color: #a0522d;">req</span>) = <span style="color: #a020f0;">delete</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_request</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">request_t</span>&lt;OPT_FIELDS&gt;&amp; <span style="color: #a0522d;">req</span>);
</pre>
</div>

<p>
See an implementation of this idea by @timtro:
<a href="https://gist.github.com/timtro/c6efbfa0c3fb9d0de1d50647ed341026">https://gist.github.com/timtro/c6efbfa0c3fb9d0de1d50647ed341026</a>
</p>

<aside class="notes">
<p>
All that's left are the driver functions.
</p>

<p>
<code>make_request</code> returns a request with all the bits set.
</p>

<p>
We have to declare, but delete <code>send_request</code> for the "higher level" types so
that they won't match the "lower level" overload. (Remember "higher level" types
derive from "lower level" types.)
</p>

<p>
This is nice use of types. Any non-setter functions can go in the zero
specialization. The type machinery is fairly lightweight if we only have a
couple of required fields, which is typical. No <code>enable_if</code>, no SFINAE, correct
code results in few type instantiations. Of course everything vanishes at
runtime.
</p>

<p>
No includes! All in the language.
</p>

</aside>

</section>
<section id="slide-org877c741">
<h3 id="org877c741">Builder Pattern Guidelines</h3>
<div class='vertspace2'></div>
<p>
Fluent style is more suitable when:
</p>

<ul>
<li>you have a single verb (<code>then</code>, <code>set_field</code>)</li>
<li>you'll be building objects a lot</li>
<li>you can make types work for you</li>
<li>rvalues aren't too verbose</li>

</ul>

<aside class="notes">
<p>
Don't use for single use. You'll be writing more code to do the same job.
</p>

<p>
Single verb, or few verbs: you don't want a huge builder interface - this also
mitigates the amount of code. You want the code to be obviously correct.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org9ff19d4">
<h2 id="org9ff19d4">Where can we go from here?</h2>
<div class='vertspace2'></div>
<p>
Where is C++ giving declarative code good support?
</p>

<p>
Where can it be improved?
</p>

</section>
<section id="slide-orgd007227">
<h3 id="orgd007227">RAII, Initialization</h3>
<div class='vertspace2'></div>
<p>
RAII is the bread-and-butter of C++ programming. It's a natural fit for a
declarative style.
</p>

<p>
Initialization is complex, but getting easier.
</p>
<ul>
<li>aggregate initialization</li>
<li>rule of zero</li>
<li>UDLs for extra expressiveness</li>
<li>class template deduction</li>
<li>C++20 designators</li>

</ul>

<aside class="notes">
<p>
Obviously, RAII is all about declaring something and letting the C++ machinery
take care of lifetime. We love it - it's what C++ is about.
</p>

<p>
Initialization is one of those areas of C++ that has been getting a lot of
scrutiny, a fair amount of "bad press" highlighting where it's not good enough
yet, so it's moving pretty strongly.
</p>

</aside>

</section>
<section id="slide-org91ecd3f">
<h3 id="org91ecd3f">Functions &amp; lambdas</h3>
<div class='vertspace2'></div>
<p>
Functions:
</p>
<ul>
<li>turn statements into expressions</li>
<li>give expressions names</li>
<li>encapsulate conditions</li>
<li>are the optimizer's bread and butter (RVO, inlining)</li>

</ul>

<p>
Structured bindings work around single-return-value limitation.
</p>

<aside class="notes">
<p>
Functions are wonderful. Higher order functions are in some sense the FP
equivalent of OO's dependency injection.
</p>

<p>
Structured bindings allow multiple "atomic" declarations.
</p>

<p>
We think about these often in the context of <code>if</code>-initialization, and they do go
well together, but if you're generally trying to avoid conditions,
<code>if</code>-initialization might become less important.
</p>

<p>
But the principle of useful return is important.
</p>

<p>
See also: no raw loops.
</p>

</aside>

</section>
<section id="slide-org95ee8ee">
<h3 id="org95ee8ee">Overloads &amp; templates</h3>
<div class='vertspace2'></div>
<p>
Parametric polymorphism: enable use of functions without conditionals.
</p>

<p>
Let the compiler do the right thing.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = A,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span>&lt;<span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span>&gt;,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">uniform_int_distribution</span>&lt;<span style="color: #228b22;">C</span>&gt;&gt;
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">numeric_limits</span>&lt;<span style="color: #228b22;">B</span>&gt;::max())
  -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_integral_v</span>&lt;<span style="color: #228b22;">C</span>&gt;, <span style="color: #228b22;">D</span>&gt;
{
  <span style="color: #a020f0;">return</span> D(a, b);
}
</pre>
</div>
<p>
Andy Bond: <i>AAAARGH!?</i> (CppCon 2016)
</p>

<p>
<a href="https://www.youtube.com/watch?v=ZCGyvPDM0YY">https://www.youtube.com/watch?v=ZCGyvPDM0YY</a>
</p>

<aside class="notes">
<p>
Adopting Almost-Always-Auto Reinforces Good Habits?
</p>

</aside>

</section>
<section id="slide-org3991294">
<h3 id="org3991294">Overloads &amp; templates</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = A,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span>&lt;<span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span>&gt;,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">uniform_real_distribution</span>&lt;<span style="color: #228b22;">C</span>&gt;&gt;
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = B{1})
  -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_floating_point_v</span>&lt;<span style="color: #228b22;">C</span>&gt;, <span style="color: #228b22;">D</span>&gt;;

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">uniform_duration_distribution</span>;

<span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">A</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">B</span> = A,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">C</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">common_type_t</span>&lt;<span style="color: #228b22;">A</span>, <span style="color: #228b22;">B</span>&gt;,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">D</span> = <span style="color: #228b22;">uniform_duration_distribution</span>&lt;<span style="color: #228b22;">C</span>&gt;&gt;
<span style="color: #a020f0;">inline</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_uniform_distribution</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">A</span>&amp; <span style="color: #a0522d;">a</span>,
                                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">B</span>&amp; <span style="color: #a0522d;">b</span> = <span style="color: #008b8b;">B</span>::max()) -&gt; <span style="color: #228b22;">D</span>;
</pre>
</div>

<aside class="notes">
<p>
With relatively little effort, we can make a type-safe uniform distribution for
chrono durations. Really useful for improving call sites and unlocking the
ability for users to be type-safe.
</p>

<p>
I use this all the time in my day job for implementing randomized network
backoffs.
</p>

</aside>

</section>
<section id="slide-org1f9cf48">
<h3 id="org1f9cf48">Inconsistencies</h3>
<div class='vertspace2'></div>
<p>
In C++17, we gained <code>if</code>- and <code>switch</code>-initializers.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">auto</span> [it, inserted] = m.emplace(<span style="color: #8b2252;">"Jenny"</span>, 8675309); inserted)
{
  <span style="color: #0000ff;">...</span>
}
</pre>
</div>
<p>
But no love for the expression equivalent of <code>if</code>.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">result</span> =
  (<span style="color: #a020f0;">auto</span> [it, inserted] = m.emplace(<span style="color: #8b2252;">"Jenny"</span>, 8675309); inserted)
  ? <span style="color: #006400;">// </span><span style="color: #006400;">some expression ...</span>
  : <span style="color: #006400;">// </span><span style="color: #006400;">some other expression ...</span>
</pre>
</div>

<aside class="notes">
<p>
<code>if</code> and the conditional operator ostensibly do the same thing, but not really.
</p>

<p>
Partly because <code>if</code> is a statement and doesn't need to obey the rules of the
type system in its two branches.
</p>

</aside>

</section>
<section id="slide-org77b2f84">
<h3 id="org77b2f84">Heritage: operators</h3>
<div class='vertspace2'></div>
<p>
C++ inherits pretty much all of its operators from C (or even earlier).
</p>

<p>
We also inherit some fixed semantics (despite operator overloading).
</p>

<p>
Operators can be amazing for expressivity of code and declarative constructs.
</p>

<aside class="notes">
<p>
Operators have a huge potential for expressing declarative code.
</p>

<p>
Unfortunately C++ operators are one of parts of the language that gets the least
attention.
</p>

</aside>

</section>
<section id="slide-org4567224">
<h3 id="org4567224">"Imperative safety gear"</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">better warnings</li>
<li class="fragment appear">static analysis</li>
<li class="fragment appear"><code>[[nodiscard]]</code> attribute (another default?)</li>
<li class="fragment appear"><code>[[fallthrough]]</code> attribute</li>
<li class="fragment appear"><code>if</code>-initializer</li>

</ul>

<aside class="notes">
<p>
We're starting to get the ability for "compilers" to help us reason about
statement sequencing. And to avoid some of the obvious historical errors.
</p>

<p>
<code>nodiscard</code> on types would prevent the unnamed lock issue.
</p>

<p>
Experiment: use <code>nodiscard</code> on every function! Is it another "wrong way round
default"?
</p>

</aside>

</section>
<section id="slide-org5cd9b6e">
<h3 id="org5cd9b6e">Richness of library help</h3>
<div class='vertspace2'></div>
<p>
Seemingly-unimportant helper functions (or metafunctions) can be very important
in avoiding conditionals.
</p>

<ul>
<li class="fragment appear"><code>std::exchange</code></li>
<li class="fragment appear"><code>std::as_const</code></li>
<li class="fragment appear"><code>std::apply</code></li>
<li class="fragment appear">expanding <code>type_traits</code></li>
<li class="fragment appear">monadic interface to <code>std::optional</code></li>

</ul>

<aside class="notes">
<p>
I love <code>std::exchange</code> - one of the most underappreciated functions in the STL.
</p>

<p>
When you start trying to deliberately limit use of statements and program more
declaratively, the use for these types of functions becomes more apparent.
</p>

</aside>

</section>
<section id="slide-orgfda9752">
<h3 id="orgfda9752">Richness of library help</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">decltype</span>(<span style="color: #a020f0;">auto</span>) <span style="color: #0000ff;">identity</span>(<span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">t</span>) {
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::forward&lt;<span style="color: #228b22;">T</span>&gt;(t);
}
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">always</span>(<span style="color: #228b22;">T</span>&amp;&amp; <span style="color: #a0522d;">t</span>) {
  <span style="color: #a020f0;">return</span> [x = <span style="color: #008b8b;">std</span>::forward&lt;<span style="color: #228b22;">T</span>&gt;(t)](<span style="color: #a020f0;">auto</span><span style="color: #0000ff;">...</span>) { <span style="color: #a020f0;">return</span> x; };
};
</pre>
</div>

<aside class="notes">
<p>
These are examples of a couple functions that exist in functional languages.
Again, the use of them isn't obvious to non-declarative programmers. Often the
use lies in getting rid of conditionals.
</p>

<p>
std::identity was in the original SGI STL.
</p>

<p>
If you do TMP, you're probably used to the idea of needing these kinds of
metafunctions. TMP doesn't have assignment, so it's by nature a lot more
declarative.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3f157bc">
<h2 id="org3f157bc">Guidelines for Declarative Code</h2>
<div class='vertspace2'></div>

<p>
Meta-guideline <i>reductio</i>: avoid writing statements.
</p>

<p>
(Principally control-flow and assignment.)
</p>

</section>
<section id="slide-org03476b3">
<h3 id="org03476b3">Replacing Conditionals</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Style</td>
<th class="org-left">Signature Element</td>
<th class="org-left">Elimination Strategy</td>
</tr>
<tr>
<td class="org-left">Imperative</td>
<td class="org-left"><div class="fragment" data-fragment-index="1">Statement</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="2">multi-computation</div></td>
</tr>
<tr>
<td class="org-left">Object-Oriented</td>
<td class="org-left"><div class="fragment" data-fragment-index="3">Object construction</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="4">polymorphism</div></td>
</tr>
<tr>
<td class="org-left">Functional</td>
<td class="org-left"><div class="fragment" data-fragment-index="5">Function call</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="6">higher order function</div></td>
</tr>
<tr>
<td class="org-left">Generic</td>
<td class="org-left"><div class="fragment" data-fragment-index="7">Type instantiation</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="8">traits class</div></td>
</tr>
</tbody>
</table>

<div class='vertspace2'></div>
<p data-fragment-index="9" class="fragment appear">
The Conditional-Replacement Meta-Pattern.
</p>

<aside class="notes">
<ul>
<li>fsel intrinsic on XBox 360</li>
<li>null object pattern</li>
<li>std::sort comparator</li>
<li><code>pointer_traits</code></li>

</ul>

<p>
This metapattern unlocks composition in all these cases. Because it turns
statements into expressions suitable for the domain.
</p>

</aside>

</section>
<section id="slide-org47cd9b2">
<h3 id="org47cd9b2">Replacing Conditionals</h3>
<div class='vertspace2'></div>
<ul>
<li class="fragment appear">Push conditionals down the callstack
<ul>
<li>intrinsic to data structures</li>
<li>optional/monadic interface</li>
<li>handle at leaf, don't leak</li>

</ul></li>
<li class="fragment appear">Push conditionals up the callstack
<ul>
<li>dependency injection</li>
<li>higher-order functions</li>
<li>power to the caller</li>
<li>lifted to root, abstracted</li>

</ul></li>
<li class="fragment appear">Goal: total functions</li>

</ul>

<aside class="notes">
<p>
Conditions get eliminated, or get pushed up or down the call stack. Pushing down
the call stack encapsulates conditions when there is some intrinsic property of
the data structure that is a condition (like optionality). Pushing up the call
stack and replacing with a behaviour that is passed in gives control to the
caller while keeping the call site declarative.
</p>

<p>
Another way to say it: treat conditionals like we treat errors: handle them and
encapsulate them at the leaf. Or push them up to the root and abstract the
condition in a construct that makes sense for your programming paradigm.
</p>

</aside>

</section>
<section id="slide-org46a7e44">
<h3 id="org46a7e44">Replacing conditionals =&gt; fewer statements</h3>
<div class='vertspace2'></div>
<p>
When you replace/encapsulate conditionals:
</p>
<ul>
<li>less call-site logic (obviously)</li>
<li>simpler, total functions</li>
<li>simpler loops (no break/continue without conditions)</li>
<li>more reason-ability</li>

</ul>

<aside class="notes">
<p>
Fewer conditions in business logic. Total functions.
</p>

</aside>

</section>
<section id="slide-org48d2345">
<h3 id="org48d2345">Replacing loops =&gt; fewer statements</h3>
<div class='vertspace2'></div>
<p>
No Raw Loops: encapsulate and replace iteration and jumps
</p>
<ul>
<li>less call-site logic</li>
<li>simpler, total functions</li>
<li>more reason-ability</li>
<li>vocabulary grows</li>

</ul>

<aside class="notes">
<p>
You're used to "no raw loops". Algorithms are functions with all the goodness of
functions.
</p>

<p>
Algorithms lock up the statements and reduce the call-site complexity. They work
with edge cases. They have names.
</p>

</aside>

</section>
<section id="slide-org7049e96">
<h3 id="org7049e96">Replacing assignments</h3>
<div class='vertspace2'></div>
<ul>
<li>Declare-at-use
<ul>
<li>use I+LEs</li>
<li>leverage <code>const</code></li>
<li>use AAA-style if you like</li>

</ul></li>
<li>Overload operators for declaration power</li>

</ul>

<aside class="notes">
<ul>
<li>Use I+LEs where appropriate for initialization</li>
<li>Leverage the power of <code>return</code></li>
<li>Operator overloading can be great and can communicate things about your types
that are otherwise hidden</li>

</ul>

</aside>

</section>
<section id="slide-org7cc4026">
<h3 id="org7cc4026">Let the language help</h3>
<div class='vertspace2'></div>
<p>
Where you can't avoid statements, use "imperative safety gear"
</p>
<ul>
<li><code>nodiscard</code> attribute</li>
<li><code>if</code>-initializer</li>
<li>static analysis</li>

</ul>

<aside class="notes">
<p>
C++ is multiparadigm. Don't let declarative style be your only hammer, except as
an exercise in discovery.
</p>

<p>
Imperative safety gear is great. And if you can find a way not to need it,
that's great too.
</p>

</aside>

</section>
<section id="slide-org91a007c">
<h3 id="org91a007c">Declarative Interfaces</h3>
<div class='vertspace2'></div>
<ul>
<li>dependency injection</li>
<li>higher-order functions</li>
<li>builder pattern / fluent style</li>
<li>identify monoids</li>
<li>start with composition</li>

</ul>

<aside class="notes">
<ul>
<li>Let callers encapsulate conditions, abstract choices</li>
<li>Consider builder/fluent-style with the earlier guidelines</li>
<li>Identify monoids - this will inform operator overloading and lead you to an
easy-to-use, compositional style</li>

</ul>

</aside>

</section>
<section id="slide-orgfa29d45">
<h3 id="orgfa29d45">Declarative Goals</h3>
<div class='vertspace2'></div>
<p>
Expressions over statements.
</p>

<p>
Declarations over assignments.
</p>

<p>
Unconditional code.
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: false,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
